{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#temperature-dependent-effective-potential","title":"Temperature dependent effective potential","text":"<p>All my phonon related codes, as well as some other stuff. It is implementing the methods published here:</p> <ul> <li> <p>Hellman, O., Abrikosov, I. A., &amp; Simak, S. I. (2011). Lattice dynamics of anharmonic solids from first principles. Physical Review B, 84(18), 180301.</p> </li> <li> <p>Hellman, O. &amp; Abrikosov, I. A. (2013). Temperature-dependent effective third-order interatomic force constants from first principles. Physical Review B, 88(14), 144301.</p> </li> <li> <p>Hellman, O., Steneteg, P., Abrikosov, I. A., &amp; Simak, S. I. (2013). Temperature dependent effective potential method for accurate free energy calculations of solids. Physical Review B, 87(10), 104111.</p> </li> </ul> <p>Briefly summarized, the package provides all the tools you need to build accurate model Hamiltonians for finite temperature lattice dynamics from first principles. In addition, there are codes to extract numerous physical properties from these model Hamiltonians, including but not limited to:</p> <ul> <li>Temperature dependent phonon frequencies</li> <li>Free energy including anharmonic contributions</li> <li>Phonon spectral functions, linewidths and shifts</li> <li>Lattice thermal conductivity</li> </ul> <p>Installation instructions and manual has its own page, including example workflows and theoretical background. This software is distributed under the MIT license. If you use it, please consider citing me.</p>"},{"location":"files/","title":"Files","text":"<p>This page details the format for all input files.</p>"},{"location":"files/#infileucposcar","title":"infile.ucposcar","text":"<p>An example of a crystal structure (this is exactly the VASP 5+ file format):</p> <pre><code>Bi2Te3\n10.314046162\n 0.243360208934  0.000000000000  0.969935981757\n-0.121680104467  0.210756123207  0.969935981757\n-0.121680104467 -0.210756123207  0.969935981757\nBi Te\n2 3\ndirect coordinates\n0.599898812406 0.599898812406 0.599898812406\n0.400101187594 0.400101187594 0.400101187594\n0.791308614612 0.791308614612 0.791308614612\n0.208691385388 0.208691385388 0.208691385388\n0.000000000000 0.000000000000 0.000000000000\n</code></pre> <p>The first line is a comment, the second line a global scaling factor \\(a\\), and the three following lines the lattice vectors \\(\\mathbf{a}_1\\),\\(\\mathbf{a}_2\\),\\(\\mathbf{a}_3\\). These will be multiplied by \\(a\\). Next is the specfication of what elements there are, and below that how many of each. The line direct coordinates specify that the coordinates of the atoms are in fractional coordinates. Each atom has it's own line, with two first specifying the Bi positions and the last three Te positions.</p>"},{"location":"files/#infilessposcar","title":"infile.ssposcar","text":"<p>This file hold the ideal positions for the atoms in the supercell. The file format is identical to the unitcell, only that the cell is larger. There is no need for the unit and supercell to be perfectly commensurate: for example with the trigonal unitcell in the example above, I used a supercell based on the hexagonal unit cell. The only requirement is that the two cells describe the same lattice. And by the same, I do not mean almost the same, I mean the same to machine precision. You can not build the supercell from ideal positions and use relaxed positions for the unitcell, for example.</p>"},{"location":"files/#infilepositions","title":"infile.positions","text":"<p>This file hold the positions. It looks something like this:</p> <pre><code>   8.2561407159200030E-005   2.2226748311341836E-003  0.99884779259537781\n  0.99849619391764632        1.3299790395140015E-003  0.20126465487180664\n  0.99942091881904371       0.99921744312226823       0.39925524034421311\n  0.99726097226994259        9.3000027090734956E-004  0.60117595839769800\n  0.99998106248734664       0.99877980293422230       0.80215876222138049\n   2.7059648117732179E-004  0.20042853805668126        9.0607694878967109E-004\n   4.7165392641841262E-004  0.20049530215652531       0.20005541126842488\n  0.99978563110732910       0.20120110797551810       0.39998540127778304\n   5.9697200870672466E-005  0.20002590513205151       0.60020279388531417\n   1.0832057274455832E-003  0.19752092901626805       0.80125606638730629\n   ...\n</code></pre> <p>and goes on for many many lines. The format is as follows:</p> row 1 \\( r_1^x \\) \\( r_1^y \\) \\( r_1^z \\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) N \\( r_N^x \\) \\( r_N^y \\) \\( r_N^z \\) N+1 \\( r_1^x \\) \\( r_1^y \\) \\( r_1^z \\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) 2N \\( r_N^x \\) \\( r_N^y \\) \\( r_N^z \\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) <p>That is the positions in fractional coordinates for each atom in the simulation cell, in the same order as in infile.ssposcar. Once all the positions are specified, it starts over with the next configuration, for a total of number of atoms times number of configurations lines.</p>"},{"location":"files/#infileforces","title":"infile.forces","text":"<p>The format for this file is nearly identical to infile.positions, only that</p> row 1 \\( f_1^x \\) \\( f_1^y \\) \\( f_1^z \\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) N \\( f_N^x \\) \\( f_N^y \\) \\( f_N^z \\) N+1 \\( f_1^x \\) \\( f_1^y \\) \\( f_1^z \\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) 2N \\( f_N^x \\) \\( f_N^y \\) \\( f_N^z \\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) <p>each line is the force on each atom in Cartesian coordinates, in eV/\u00c5. Again, a total of number of atoms times number of configurations lines.</p>"},{"location":"files/#infilestat","title":"infile.stat","text":"<p>This file contains all the energy and stresses in the following format:</p> row 1 i \\(t\\) \\(E_t\\) \\(E_p\\) \\(E_k\\) \\(T\\) \\(P\\) \\(\\sigma_{xx}\\) \\(\\sigma_{yy}\\) \\(\\sigma_{zz}\\) \\(\\sigma_{xz}\\) \\(\\sigma_{yz}\\) \\(\\sigma_{xy}\\) 2 i \\(t\\) \\(E_t\\) \\(E_p\\) \\(E_k\\) \\(T\\) \\(P\\) \\(\\sigma_{xx}\\) \\(\\sigma_{yy}\\) \\(\\sigma_{zz}\\) \\(\\sigma_{xz}\\) \\(\\sigma_{yz}\\) \\(\\sigma_{xy}\\) 3 i \\(t\\) \\(E_t\\) \\(E_p\\) \\(E_k\\) \\(T\\) \\(P\\) \\(\\sigma_{xx}\\) \\(\\sigma_{yy}\\) \\(\\sigma_{zz}\\) \\(\\sigma_{xz}\\) \\(\\sigma_{yz}\\) \\(\\sigma_{xy}\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) <p>The columns are, in order configuration (integer), time (in fs), total energy, potential energy, kinetic energy, temperature, pressure and stress tensor. Energies are in eV/supercell, temperature in K, pressures and stress tensor in GPa. There is one line per configuration in the simulation.</p> <p>One line for every configuration in the simulation. The energies are in eV/supercell, temperature in K, pressure and stress in GPa.</p> <p>Note</p> <p>The information in this file is only crucial when calculating the free energy. For other applications this can safely be filled with mock data, in case the method you use to calculate forces does not output e.g. stress tensors.</p> <p>Note</p> <p>In case you use stochastic sampling, the time column is of no importance and can be set to any number. However, the column still needs to exist in the file.</p>"},{"location":"files/#infilemeta","title":"infile.meta","text":"<p>Some information about the MD run, an example:</p> <pre><code>240    # N atoms\n2000   # N timesteps\n1.0    # timestep in fs\n300    # temperature in K\n</code></pre> <p>The first line is the number of atoms in the simulation, the second line the number of timesteps. Then the timestep and the temperature.</p> <p>Note</p> <p>The timestep and temperature can safely be set to 0 in case you use stochastic sampling.</p>"},{"location":"files/#infilelotosplitting","title":"infile.lotosplitting","text":"<p>This is an example input file for the long-range electrostatic corrections, also for Bi2Te3.</p> <pre><code> 5.0  0.0  0.0 # three lines for dielectric tensor\n 0.0  5.0  0.0\n 0.0  0.0  7.5\n 8.0  0.0  0.0 # Born effective charge for atom 1, three lines\n 0.0  8.0  0.0\n 0.0  0.0  2.5\n 8.0  0.0  0.0 # Born effective charge for atom 2, three lines\n 0.0  8.0  0.0\n 0.0  0.0  2.5\n-4.5  0.0  0.0 # Born effective charge for atom 3, three lines\n 0.0 -4.5  0.0\n 0.0  0.0 -0.5\n-4.5  0.0  0.0 # Born effective charge for atom 4, three lines\n 0.0 -4.5  0.0\n 0.0  0.0 -0.5\n-7.0  0.0  0.0 # Born effective charge for atom 5, three lines\n 0.0 -7.0  0.0\n 0.0  0.0 -5.1\n</code></pre> <p>The first three lines is the dielectric tensor, after that three lines per atom in infile.ucposcar with the Born effective charges. The dielectric tensor is unitless, and the Born effective charges are in electron charges.</p> <p>It is important to note that in general, the Born effective charges are not necessarily symmetric:</p> \\[ Z_i^{\\alpha\\beta} = \\frac{\\partial^2 U}{\\partial \\epsilon_i^{\\alpha} \\partial u_i^{\\beta}} \\] <p>That is derivative with respect to electric field and position. This means it matters how you enter them. In this input file, the convention is as follows:</p> \\[ \\begin{pmatrix}     \\partial_{\\epsilon x}\\partial_{ux} &amp; \\partial_{\\epsilon x}\\partial_{uy} &amp; \\partial_{\\epsilon x}\\partial_{uz} \\\\     \\partial_{\\epsilon y}\\partial_{ux} &amp; \\partial_{\\epsilon y}\\partial_{uy} &amp; \\partial_{\\epsilon y}\\partial_{uz} \\\\     \\partial_{\\epsilon z}\\partial_{ux} &amp; \\partial_{\\epsilon z}\\partial_{uy} &amp; \\partial_{\\epsilon z}\\partial_{uz} \\end{pmatrix} \\]"},{"location":"files/#infileqpoints_dispersion","title":"infile.qpoints_dispersion","text":"<p>Many programs output properties along a path in the BZ. Per default, this is generated procedurally. In case the default is not satisfactory, you have the possibility to specify a path.</p> <pre><code>FCC                         ! Bravais lattice type\n  100                       ! Number of points on each path\n    4                       ! Number paths between special points\nGM  X                       ! Starting and ending special point\nX   U                       !\nK   GM                      !\nGM  L                       !\n</code></pre> <p>Where the first line specify the Bravais family, followed by the number of points on each line segment and the number of line segments. Each line segment is specified by two labels. Use crystal structure info to get a list of the possible labels and their coordinates. If this is not flexible enough, an arbitrary path can be specified</p> <pre><code>CUSTOM                      !\n  100                       ! Number of points on each path\n    4                       ! Number paths between special points\n0.000 0.000 0.000   0.000 0.500 0.500 GM X\n0.000 0.500 0.500   0.000 0.625 0.375 X  U\n0.375 0.750 0.375   0.000 0.000 0.000 K  GM\n0.000 0.000 0.000   0.000 0.500 0.000 GM L\n</code></pre> <p>This is the same path as above, but explicitly specified. Each segment is specified by 3+3 numbers and two labels. The coordinates are reciprocal fractional.</p>"},{"location":"files/#infileisotopes","title":"infile.isotopes","text":"<p>The phonon many-body perturbation theory considers scattering by isotopes. By default, they will use the natural distribution (tabulated in the code, taken from the symbol in infile.ucposcar). In case you want to specify some other distribution, you can:</p> <pre><code>1         # number of isotopes for first atom in infile.ucposcar\n1 28.0855 # concentration, mass, one line per isotope\n2         # number of isotopes for second atom\n0.5 12.0  # concentration, mass\n0.5 13.0  # concentration, mass\n...\n</code></pre> <p>Per atom in the unit cell, you specify the number of isotopes, followed by the appropriate number of concentrations and masses (in atomic mass units).</p>"},{"location":"program/anharmonic_free_energy/","title":"Anharmonic free energy","text":""},{"location":"program/anharmonic_free_energy/#short-description","title":"Short description","text":"<p>End world hunger!</p>"},{"location":"program/anharmonic_free_energy/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--temperature value</code>     default value 300     Temperature used in the occupation numbers. Should be the same as the temperature the force constants where determined at.</p> </li> <li> <p><code>--qpoint_grid value#1 value#2 value#3</code>, <code>-qg value#1 value#2 value#3</code>     default value 26 26 26     Density of q-point mesh for Brillouin zone integrations.</p> </li> <li> <p><code>--integrationtype value</code>, <code>-it value</code>, value in: <code>1,2,3</code>     default value 2     Type of integration. 1 is Gaussian, 2 adaptive Gaussian and 3 Tetrahedron.</p> </li> <li> <p><code>--sigma value</code>     default value 1.0     Global scaling factor for Gaussian/adaptive Gaussian smearing. The default is determined procedurally, and scaled by this number.</p> </li> <li> <p><code>--path</code>     default value .false.     mutually exclude \"--temperature_range\"     Calculate the anharmonic free energy on a path through the BZ.</p> </li> <li> <p><code>--support_qpoint_grid value#1 value#2 value#3</code>, <code>-sqg value#1 value#2 value#3</code>     default value -1 -1 -1     Interpolate to a (preferrably) denser q-mesh when calculating the DOS.</p> </li> <li> <p><code>--temperature_range value#1 value#2 value#3</code>     default value -1 -1 -1     mutually exclude \"--path\"     Evaluate thermodynamic phonon properties for a series of temperatures, specify min, max and the number of points.</p> </li> <li> <p><code>--readiso</code>     default value .false.     Read the isotope distribution from file</p> </li> <li> <p><code>--meshtype value</code>, value in: <code>1,2,3,4</code>     default value 1     Type of q-point mesh. 1 Is a Monkhorst-Pack mesh, 2 an FFT mesh and 3 my fancy wedge-based mesh with approximately the same density the grid-based meshes. 4 build the commensurate mesh of an approximately cubic supercell.</p> </li> <li> <p><code>--readqmesh</code>     default value .false.     Read the q-point mesh from file. To generate a q-mesh file, see the genkpoints utility.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/anharmonic_free_energy/#examples","title":"Examples","text":"<p><code>mpirun anharmonic_free_energy</code> </p> <p>This code calculates the anharmonic Helmholtz free energy. It includes the contributions from baseline shifts, renormalized phonons and higher order terms.</p>"},{"location":"program/anharmonic_free_energy/#free-energy","title":"Free energy","text":"<p>@todo Explain the basics of free energy, entropies and so on.</p>"},{"location":"program/anharmonic_free_energy/#second-order-terms","title":"Second order terms","text":"<p>The details an notation how to calculate phonon can be found phonon_dispersion_relations, and I follow the same notation here. In the previous section, we treated the vibrations of atoms classically, by solving Newton's equations of motion. Quantum-mechanically, vibrational normal modes can be represented as quasi-particles called phonons, quanta of thermal energy. We note that our normal mode transformation is a sum over eigenfunctions of independent harmonic oscillators. This allows us to write the position and momentum operators in terms of creation and annihilation operators (without loss of generality, we can contract the notation for phonon mode \\(s\\) at wave vector \\(\\mathbf{q}\\) to a single index \\(\\lambda\\)):</p> \\[ \\begin{align} \\hat{u}_{i\\alpha} = &amp; \\sqrt{ \\frac{\\hbar}{2N m_\\alpha} } \\sum_\\lambda \\frac{\\epsilon_\\lambda^{i\\alpha}}{ \\sqrt{ \\omega_\\lambda} } e^{i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\hat{a}^{\\mathstrut}_\\lambda + \\hat{a}^\\dagger_\\lambda \\right) \\\\ % \\hat{p}_{i\\alpha} = &amp; \\sqrt{ \\frac{\\hbar m_\\alpha}{2N} } \\sum_\\lambda \\sqrt{ \\omega_\\lambda } \\epsilon_\\lambda^{i\\alpha} e^{i\\mathbf{q}\\cdot\\mathbf{r}_i-\\pi/2} \\left( \\hat{a}^{\\mathstrut}_\\lambda - \\hat{a}^\\dagger_\\lambda \\right) % \\end{align} \\] <p>and their inverse</p> \\[ \\begin{align} \\hat{a}^{\\mathstrut}_{\\lambda} = &amp; \\frac{1}{\\sqrt{2N\\hbar}} \\sum_{i\\alpha} \\epsilon_\\lambda^{i\\alpha} e^{-i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\sqrt{m_i \\omega_\\lambda} \\hat{u}_{i\\alpha}-i \\frac{\\hat{p}_{i\\alpha}}{ \\sqrt{ m_i \\omega_\\lambda }} \\right) \\\\ % \\hat{a}^\\dagger_{\\lambda} = &amp; \\frac{1}{\\sqrt{2N\\hbar}} \\sum_{i\\alpha} \\epsilon_\\lambda^{i\\alpha} e^{i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\sqrt{m_i \\omega_\\lambda} \\hat{u}_{i\\alpha}-i \\frac{\\hat{p}_{i\\alpha}}{ \\sqrt{ m_i \\omega_\\lambda }} \\right) \\end{align} \\] <p>In terms of these operators, the vibrational Hamiltonian can be written as</p> \\[ \\begin{equation} \\hat{H}=\\sum_{\\lambda}\\hbar\\omega_\\lambda \\left( \\hat{a}^\\dagger_\\lambda \\hat{a}^{\\mathstrut}_\\lambda + \\frac{1}{2}\\right)\\,. \\end{equation} \\] <p>Since \\(\\hat{a}^\\dagger_\\lambda \\hat{a}^{\\mathstrut}_\\lambda\\) are commutative operators, the Hamiltonian is that of a sum of uncoupled harmonic quantum oscillators, each having the partition function</p> \\[ \\begin{equation} Z_{\\lambda}=\\sum_{n=0}^{\\infty}e^{-\\beta (n +\\frac{1}{2})\\hbar\\omega_{\\lambda} } = \\frac{ e^{-\\beta \\hbar\\omega_{\\lambda}/2 } }{1-e^{-\\beta \\hbar\\omega_{\\lambda}}} \\end{equation} \\] <p>that gives the total partition function</p> \\[ \\begin{equation} Z=\\prod_{\\lambda} \\frac{ e^{-\\beta \\hbar\\omega_{\\lambda}/2 } }{1-e^{-\\beta \\hbar\\omega_{\\lambda}}}. \\end{equation} \\] <p>From this we can get the Helmholtz (phonon) free energy:</p> \\[ \\begin{equation} F_{\\textrm{ph}}= -k_B T \\ln Z = \\sum_{\\lambda} \\frac{\\hbar \\omega_{\\lambda}}{2}+k_B T% \\ln \\left( 1- \\exp \\left( -\\frac{\\hbar \\omega_{\\lambda}}{k_B T} \\right) \\right) \\end{equation} \\] <p>@todo copy-paste from thesis or something</p>"},{"location":"program/anharmonic_free_energy/#higher-order-terms","title":"Higher order terms","text":"<p>@todo copy-paste from paper</p>"},{"location":"program/anharmonic_free_energy/#baseline-renormalization","title":"Baseline renormalization","text":"<p>In the conventional quasiharmonic approximation, the total free energy of the system (not considering any terms pertaining to magnetic or configurational degrees of freedom) can be expressed as</p> \\[ \\begin{equation}     F = F_{\\textrm{el}} + F_{\\textrm{ph}}\\,. \\end{equation} \\] <p>In the TDEP formalism it is not quite that simple.</p>"},{"location":"program/anharmonic_free_energy/#determining-the-free-energy-with-tdep","title":"Determining the free energy with TDEP","text":"<p>In the TDEP formalism,4,3,2 with effective force constants, the phonon quasiparticles are different at each temperature. At fix temperature, they behave just like normal bosons, obeying Bose-Einstein statistics and so on. But changing the temperature will change both the occupation numbers and the states that are occupied. Moreover, in the harmonic approximation the baseline energy (with all atoms at their equilibrium positions) is that of the static lattice. With an effective Hamiltonian this baseline is a free parameter. The baseline shift is illustrated in the diagram below:</p> <p></p> <p>The density depicts the phase space samples used to fit the effective Hamiltonian. The reference energy, or baseline, has been shifted with respect to zero temperature. This baseline is determined by matching the potential energies of the samples of the Born-Oppenheimer surface, \\(U_{BO}\\), and the potential energy of the TDEP model Hamiltonian:</p> \\[ \\begin{equation} \\begin{split}     \\left\\langle U_{\\textrm{BO}} - U_{\\textrm{TDEP}} \\right\\rangle &amp; =     \\left\\langle U_{\\textrm{BO}} - U_0 -\\frac{1}{2} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi_{ij}^{\\alpha\\beta} u^{\\alpha}_i u^{\\beta}_j  \\right\\rangle = 0 \\\\     U_0 &amp; = \\left\\langle U_{\\textrm{BO}} - \\frac{1}{2} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi_{ij}^{\\alpha\\beta} u^{\\alpha}_i u^{\\beta}_j \\right\\rangle \\end{split} \\end{equation} \\] <p>Intuitively, this can be interpreted as that the TDEP force constants are determined by matching forces between the real and model system, in a similar manner we match the energies as well. The new baseline is conveniently expressed as a shift:</p> \\[ \\begin{equation}     \\Delta U = U_0-U_{\\textrm{stat}} \\end{equation} \\] <p>Where \\(U_{\\textrm{stat}}\\) is the energy of the perfect lattice at 0K. The free energy is then (excluding configurational entropy, magnetic entropy etc.)</p> \\[ \\begin{equation}     F = F_{\\textrm{el}} + F_{\\textrm{ph}} + \\Delta U_0\\,. \\end{equation} \\]"},{"location":"program/anharmonic_free_energy/#why-does-this-code-not-output-entropy","title":"Why does this code not output entropy?","text":"<p>@todo Refer to Cowley</p> <p>@todo Simple explanation with partial derivatives</p> <p>@todo Plot with heat capacity</p>"},{"location":"program/anharmonic_free_energy/#harmonic-thermodynamics","title":"Harmonic thermodynamics","text":"<p>In the previous section, we treated the vibrations of atoms classically, by solving Newton's equations of motion. Quantum-mechanically, vibrational normal modes can be represented as quasi-particles called phonons, quanta of thermal energy. We note that our normal mode transformation is a sum over eigenfunctions of independent harmonic oscillators. This allows us to write the position and momentum operators in terms of creation and annihilation operators (without loss of generality, we can contract the notation for phonon mode \\(s\\) at wave vector \\(\\mathbf{q}\\) to a single index \\(\\lambda\\)):</p> \\[ \\begin{align} \\hat{u}_{i\\alpha} = &amp; \\sqrt{ \\frac{\\hbar}{2N m_\\alpha} } \\sum_\\lambda \\frac{\\epsilon_\\lambda^{i\\alpha}}{ \\sqrt{ \\omega_\\lambda} } e^{i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\hat{a}^{\\mathstrut}_\\lambda + \\hat{a}^\\dagger_\\lambda \\right) \\\\ % \\hat{p}_{i\\alpha} = &amp; \\sqrt{ \\frac{\\hbar m_\\alpha}{2N} } \\sum_\\lambda \\sqrt{ \\omega_\\lambda } \\epsilon_\\lambda^{i\\alpha} e^{i\\mathbf{q}\\cdot\\mathbf{r}_i-\\pi/2} \\left( \\hat{a}^{\\mathstrut}_\\lambda - \\hat{a}^\\dagger_\\lambda \\right) % \\end{align} \\] <p>and their inverse</p> \\[ \\begin{align} \\hat{a}^{\\mathstrut}_{\\lambda} = &amp; \\frac{1}{\\sqrt{2N\\hbar}} \\sum_{i\\alpha} \\epsilon_\\lambda^{i\\alpha} e^{-i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\sqrt{m_i \\omega_\\lambda} \\hat{u}_{i\\alpha}-i \\frac{\\hat{p}_{i\\alpha}}{ \\sqrt{ m_i \\omega_\\lambda }} \\right) \\\\ % \\hat{a}^\\dagger_{\\lambda} = &amp; \\frac{1}{\\sqrt{2N\\hbar}} \\sum_{i\\alpha} \\epsilon_\\lambda^{i\\alpha} e^{i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\sqrt{m_i \\omega_\\lambda} \\hat{u}_{i\\alpha}-i \\frac{\\hat{p}_{i\\alpha}}{ \\sqrt{ m_i \\omega_\\lambda }} \\right) \\end{align} \\] <p>In terms of these operators, the vibrational Hamiltonian can be written as</p> \\[ \\begin{equation} \\hat{H}=\\sum_{\\lambda}\\hbar\\omega_\\lambda \\left( \\hat{a}^\\dagger_\\lambda \\hat{a}^{\\mathstrut}_\\lambda + \\frac{1}{2}\\right)\\,. \\end{equation} \\] <p>Since \\(\\hat{a}^\\dagger_\\lambda \\hat{a}^{\\mathstrut}_\\lambda\\) are commutative operators, the Hamiltonian is that of a sum of uncoupled harmonic quantum oscillators, each having the partition function</p> \\[ \\begin{equation} Z_{\\lambda}=\\sum_{n=0}^{\\infty}e^{-\\beta (n +\\frac{1}{2})\\hbar\\omega_{\\lambda} } = \\frac{ e^{-\\beta \\hbar\\omega_{\\lambda}/2 } }{1-e^{-\\beta \\hbar\\omega_{\\lambda}}} \\end{equation} \\] <p>that gives the total</p> \\[ \\begin{equation} Z=\\prod_{\\lambda} \\frac{ e^{-\\beta \\hbar\\omega_{\\lambda}/2 } }{1-e^{-\\beta \\hbar\\omega_{\\lambda}}}. \\end{equation} \\] <p>From this we can get the Helmholtz (phonon) free energy:</p> \\[ \\begin{equation} F_{\\textrm{ph}}= -k_B T \\ln Z = \\sum_{\\lambda} \\frac{\\hbar \\omega_{\\lambda}}{2}+k_B T% \\ln \\left( 1- \\exp \\left( -\\frac{\\hbar \\omega_{\\lambda}}{k_B T} \\right) \\right) \\end{equation} \\] <p>In the conventional quasiharmonic approximation, the total free energy of the system (not considering any terms pertaining to magnetic or configurational degrees of freedom) can be expressed as</p> \\[ \\begin{equation}     F = F_{\\textrm{el}} + F_{\\textrm{ph}}\\,. \\end{equation} \\] <p>In the TDEP formalism it is not quite that simple.</p>"},{"location":"program/anharmonic_free_energy/#determining-the-free-energy-with-tdep_1","title":"Determining the free energy with TDEP","text":"<p>In the TDEP formalism,4,3,2 with effective force constants, the phonon quasiparticles are different at each temperature. At fix temperature, they behave just like normal bosons, obeying Bose-Einstein statistics and so on. But changing the temperature will change both the occupation numbers and the states that are occupied. Moreover, in the harmonic approximation the baseline energy (with all atoms at their equilibrium positions) is that of the static lattice. With an effective Hamiltonian this baseline is a free parameter. The baseline shift is illustrated in the diagram below:</p> <p></p> <p>The density depicts the phase space samples used to fit the effective Hamiltonian. The reference energy, or baseline, has been shifted with respect to zero temperature. This baseline is determined by matching the potential energies of the samples of the Born-Oppenheimer surface, \\(U_{BO}\\), and the potential energy of the TDEP model Hamiltonian:</p> \\[ \\begin{equation} \\begin{split}     \\left\\langle U_{\\textrm{BO}} - U_{\\textrm{TDEP}} \\right\\rangle &amp; =     \\left\\langle U_{\\textrm{BO}} - U_0 -\\frac{1}{2} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi_{ij}^{\\alpha\\beta} u^{\\alpha}_i u^{\\beta}_j  \\right\\rangle = 0 \\\\     U_0 &amp; = \\left\\langle U_{\\textrm{BO}} - \\frac{1}{2} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi_{ij}^{\\alpha\\beta} u^{\\alpha}_i u^{\\beta}_j \\right\\rangle \\end{split} \\end{equation} \\] <p>Intuitively, this can be interpreted as that the TDEP force constants are determined by matching forces between the real and model system, in a similar manner we match the energies as well. The new baseline is conveniently expressed as a shift:</p> \\[ \\begin{equation}     \\Delta U = U_0-U_{\\textrm{stat}} \\end{equation} \\] <p>Where \\(U_{\\textrm{stat}}\\) is the energy of the perfect lattice at 0K. The free energy is then (excluding configurational entropy, magnetic entropy etc.)</p> \\[ \\begin{equation}     F = F_{\\textrm{el}} + F_{\\textrm{ph}} + \\Delta U_0\\,. \\end{equation} \\] <p>The entropy and heat capacity is not accessible from a single simulation. Since both the phonon free energy and baseline shift have non-trivial temperature dependencies, a series of calculations for different temperatures are needed, so that the entropy can be calculated via</p> \\[ \\begin{equation}     S = -\\left.\\frac{dF}{dT}\\right|_{V} \\end{equation} \\] <p>A series of calculations on a volume-temperature grid is required to calculate Gibbs free energy, with pressure explicitly calculated as</p> \\[ \\begin{equation}     P = -\\left.\\frac{dF}{dV}\\right|_T \\end{equation} \\]"},{"location":"program/anharmonic_free_energy/#harmonic-thermodynamics_1","title":"Harmonic thermodynamics","text":"<p>The entropy and heat capacity is not accessible from a single simulation. Since both the phonon free energy and baseline shift have non-trivial temperature dependencies, a series of calculations for different temperatures are needed, so that the entropy can be calculated via</p> \\[ \\begin{equation}     S = -\\left._{}\\frac{dF}{dT}\\right|_{V} \\end{equation} \\] <p>A series of calculations on a volume-temperature grid is required to calculate Gibbs free energy, with pressure explicitly calculated as</p> \\[ \\begin{equation}     P = -\\left._{}\\frac{dF}{dV}\\right|_{T} \\end{equation} \\] <p>Or something.</p>"},{"location":"program/anharmonic_free_energy/#output-files","title":"Output files","text":"<p>Using option <code>--dumpgrid</code> writes all phonon properties for a grid in the BZ to an hdf5 file, that is self-documented.</p> <ol> <li> <p>Born, M., &amp; Huang, K. (1964). Dynamical theory of crystal lattices. Oxford: Oxford University Press.\u00a0\u21a9</p> </li> <li> <p>Hellman, O., Abrikosov, I. A., &amp; Simak, S. I. (2011). Lattice dynamics of anharmonic solids from first principles. Physical Review B, 84(18), 180301. \u21a9\u21a9</p> </li> <li> <p>Hellman, O., &amp; Abrikosov, I. A. (2013). Temperature-dependent effective third-order interatomic force constants from first principles. Physical Review B, 88(14), 144301. \u21a9\u21a9</p> </li> <li> <p>Hellman, O., Steneteg, P., Abrikosov, I. A., &amp; Simak, S. I. (2013). Temperature dependent effective potential method for accurate free energy calculations of solids. Physical Review B, 87(10), 104111. \u21a9\u21a9</p> </li> <li> <p>Gonze, X., Charlier, J.-C., Allan, D. C. &amp; Teter, M. P. Interatomic force constants from first principles: The case of \u03b1-quartz. Phys. Rev. B 50, 13035\u201313038 (1994). \u21a9</p> </li> <li> <p>Gonze, X. &amp; Lee, C. Dynamical matrices, Born effective charges, dielectric permittivity tensors, and interatomic force constants from density-functional perturbation theory. Phys. Rev. B 55, 10355\u201310368 (1997). \u21a9</p> </li> </ol>"},{"location":"program/atomic_distribution/","title":"Atomic distribution","text":""},{"location":"program/atomic_distribution/#short-description","title":"Short description","text":"<p>Calculates properties of the atomic distribution from molecular dynamics, such as mean square displacement, pair distribution function, vector distribution functions and probability densities. Useful for analysing simulations close to instabilities/phase transitions to have some idea where the atoms are.</p>"},{"location":"program/atomic_distribution/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--cutoff value</code>, <code>-r value</code>     default value 5.0     Consider pairs up to this distance, in A.</p> </li> <li> <p><code>--nbins value</code>, <code>-n value</code>     default value 300     Number of bins in each dimension.</p> </li> <li> <p><code>--notransform</code>     default value .false.     Do no rotate the coordinate systems of the vector distribution. By default, the coordinate system is aligned with the positive x-direction in the direction of the bond.</p> </li> <li> <p><code>--bintype value</code>, value in: <code>1,2,3</code>     default value 1     Select the binning type for the vector distribution. 1 is straight binning (fastest), 2 is binning with a Gaussian, 3 is binning with a gaussian, but without the subpixel resolution.</p> </li> <li> <p><code>--stride value</code>, <code>-s value</code>     default value 1     Use every N configuration instead of all.</p> </li> <li> <p><code>--nodiffusion</code>     default value .false.     Treat the system as though it is crystalline and not diffusing, not matter what.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/atomic_distribution/#examples","title":"Examples","text":"<p><code>atomic_distribution --cutoff 4.3</code> </p> <p><code>atomic_distribution --cutoff 4.3 --notransform</code> </p>"},{"location":"program/atomic_distribution/#what-can-this-code-produce","title":"What can this code produce","text":"<p>@todo Add example plots</p>"},{"location":"program/atomic_distribution/#long-description","title":"Long description","text":"<p>When using molecular dynamics, there are several ways to analyse the trajectories. This code implements a few of them. The TDEP method was originally meant to deal with dynamically unstable systems. It turns out the the most common problem for users was that the atoms did something during the simulation: what they thought was bcc Ti was no longer bcc Ti, but some halfway phase on it's way to transition to something.</p> <p>So, before trying to get phonons and free energies and other things, it it useful to make sure that what is in your simulation box actually is what you think it is. A number of diagnostics is provided here.</p>"},{"location":"program/atomic_distribution/#some-background","title":"Some background","text":"<p>The easiest measure is the mean square displacement:</p> \\[ \\textrm{msd}(t) = \\frac{1}{N} \\sum_i \\left| \\mathbf{r}_i(t)-\\mathbf{r}_i(0) \\right|^2 \\] <p>where \\(\\mathbf{r}_i(t)\\) is the position of atom \\(i\\) at time \\(t\\). To be able to use the rest of the methods in this package the system needs to be solid. In a solid the mean square displacement fluctuates with time, but does not grow. If you find strange results, the mean square displacement is the first thing to check.</p> <p>Having established that the system is at least still a solid we can look at the radial distribution function (or pair correlation function), defined as</p> \\[ g(r) = \\frac{ n(r) }{\\rho 4 \\pi r^2 dr} \\] <p>where \\(\\rho\\) is the mean particle density, and \\(n(r)\\) the number of particles in an infinitesimal shell of width \\(dr\\). Usually, this is averaged over all atoms in the system. In this code, I project it onto symmetrically equivalent pairs, yielding a projected pair distribution:</p> \\[ g_i(r) = {\\rho 4 \\pi r^2 dr} \\sum_i \\delta\\left( \\left|r_i\\right|-r \\right) \\] <p>where the index \\(i\\) corresponds to a coordination shell. The coordination shell is defined from the ideal lattice as set of pairs that can transform to each other via a spacegroup operation. Naturally, the sum over all projected PDFs yield the total.</p> <p>@todo Update this picture to something valid.</p> <p> </p> <p>Above is an example for ScF3. The peaks are well defined per pair, indicating that the system is still crystalline. In the projected picture, each coordination shell contributes one peak. Should on peak deviate strongly from a gaussian, it probably means that the system has undergone some internal shifts of the coordinates, altering the symmetry.</p> <p>This code also calculates the vector distribution function, essentially three-dimensionsonal histograms of pair vectors. Schematically, it works like this: first I identify the symmetry inequivalent pair coordination shells (turqoise and blue arrows below). Each pair in the simulation cell gets a transformation associated with it (dashed lines) that takes them to the prototype vectors (connecting the dark blue atoms)</p> <p> </p> <p>With these transformation rules, every pair from every timestep gets transformed, and binned in a histogram. The histogram is attached to the ideal bond, so that the origin coincides with the equilibrium pair vector. The coordinate system is also rotated such that the positive \\(z\\)-direction coincides with the pair vector, see the sketch below. The blue dots represent samples from pairs associated with blue vectors above, same for the green dots.</p> <p> </p> <p>This results in three-dimensional distributions of pair vectors, one for each symmetry-distinct pair. This is a measure related to the pair correlation functions, but spatially resolved. If the distribution is given by \\(n(\\mathbf{r})\\), integrating this over spherical shells gives the pair correlation function described above. Using the same example as above, ScF3, isosurfaces of the distribution look like this for the nearest neighbour Sc-F pair:</p> <p> </p> <p>@todo Explain relation between radial distribution function and stochastic sampling, link to mine and Bin's paper.</p>"},{"location":"program/atomic_distribution/#input-files","title":"Input files","text":"<ul> <li>infile.ucposcar</li> <li>infile.ssposcar</li> <li>infile.meta</li> <li>infile.stat</li> <li>infile.positions</li> <li>infile.forces</li> </ul>"},{"location":"program/atomic_distribution/#output-files","title":"Output files","text":""},{"location":"program/atomic_distribution/#outfilemean_square_displacementhdf5","title":"<code>outfile.mean_square_displacement.hdf5</code>","text":"<p>The hdf file is self-explainatory. In addition, a plain-text <code>outfile.mean_square_displacement</code> is written with</p> Row Description 1      \\( t_1 \\qquad \\textrm{msd}(t_1) \\qquad \\textrm{msd}_1(t_1) \\qquad \\ldots \\qquad \\textrm{msd}_{N_a}(t_1) \\)      2      \\( t_2 \\qquad \\textrm{msd}(t_2) \\qquad \\textrm{msd}_1(t_2) \\qquad \\ldots \\qquad \\textrm{msd}_{N_a}(t_2) \\)      ... ... <p>Where the columns are time (in fs), mean square displacement (in \u00c52), followed by the partial mean square displacement per unique atom.</p>"},{"location":"program/atomic_distribution/#outfilepair_distribution_functionhdf5","title":"<code>outfile.pair_distribution_function.hdf5</code>","text":"<p>The hdf file is self-explainatory. Below is a matlab snippet that produces the plot above</p> <pre><code>clear all;\n% filename\nfn='outfile.pair_distribution_function.hdf5';\n% number of unique atoms\nna=h5readatt(fn,'/','number_unique_atoms');\n% the total\nx=h5read(fn,'/r_axis');\ny=h5read(fn,'/radial_pair_distribution_function');\n% the projected\nfor i=1:na\nxx{i}=h5read(fn,['/projected_r_axis_' num2str(i)]);\nyy{i}=h5read(fn,['/projected_pair_distribution_function_atom_' num2str(i)]);\nend\nfigure(1); clf; hold on; box on;\n% plot the total\nplot(x,y)\n% plot the projected\nfor i=1:na\nfor j=1:size(xx{i},1)\nplot(xx{i}(j,:),yy{i}(j,:))\nend\nend\nset(gca,'xminortick','on','yminortick','on')\nxlabel('Distance (A)')\nylabel('g(r)')\n</code></pre> <p>and an equivalent snippet using matplotlib:</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport h5py as h5\n# open the sqe file\nf = h5.File('outfile.pair_distribution_function.hdf5','r')\n# the total\nx = np.array(f.get('r_axis'))\ny = np.array(f.get('radial_pair_distribution_function'))\nplt.plot(x,y)\n# the projected\nna = f.attrs.get('number_unique_atoms')\nfor i in range(na):\nx = np.array(f.get('projected_r_axis_'+str(i+1)))\ny = np.array(f.get('projected_pair_distribution_function_atom_'+str(i+1)))\nfor j in range(x.shape[1]):\nplt.plot(x[:,j],y[:,j])\nplt.xlabel(\"Distance (A)\")\nplt.ylabel(\"g(r)\")\nplt.show()\n</code></pre>"},{"location":"program/atomic_distribution/#outfilevector_distributionhdf5","title":"<code>outfile.vector_distribution.hdf5</code>","text":"<p>This file contains all the vector distribution histograms, the prototype vectors, the transformations to the correct coordinate systems and so on. The file is self-documented. The following is the matlab snippet used to create the plot above:</p> <pre><code>% file\nfn='outfile.vector_distribution.hdf5';\n% focus on one distribution, get the histogram\ngv=h5read(fn,'/distribution_atom_1_shell_2');\n% and the coordinates for the bin-centers\nx=h5readatt(fn,'/distribution_atom_1_shell_2','bincenters');\n% grids for plotting (always uniform)\n[gx,gy,gz]=meshgrid(x,x,x);\nfigure(1); clf; hold on;\n% number of isosurfaces\nniv=6;\n% values for the isosurfaces\niv=exp( linspace(log(0.01),log(1.5),niv) );\nsubplot(1,2,1); hold on;\nfor i=1:niv\np = patch(isosurface(gx,gy,gz,gv,iv(i)));\nisonormals(gx,gy,gz,gv, p)\np.FaceColor = [0.7 0.1 0.1];\np.EdgeColor = 'none';\nalpha(p,0.25);\nend\ndaspect([1 1 1])\nview([0 1])\ncamlight; lighting phong\nxlabel('x')\nylabel('y')\nzlabel('z')\nsubplot(1,2,2); hold on;\nfor i=1:length(iv)\np = patch(isosurface(gx,gy,gz,gv,iv(i)));\nisonormals(gx,gy,gz,gv, p)\np.FaceColor = [0.7 0.1 0.1];\np.EdgeColor = 'none';\nalpha(p,0.25);\nend\ndaspect([1 1 1])\nview([0 0 1])\ncamlight; lighting phong\nxlabel('x')\nylabel('y')\nzlabel('z')\n</code></pre> <p>@note I could not figure out an easy way to get decent-looking isosurfaces in matplotlib. Please tell me if you manage.</p>"},{"location":"program/canonical_configuration/","title":"Canonical configuration","text":""},{"location":"program/canonical_configuration/#short-description","title":"Short description","text":"<p>Use forceconstants or a Debye temperature to generate uncorrelated supercell configurations emulating a canonical ensemble. These configurations can be used to either start ensemble runs of molecular dynamics with negligible equilibration time, or be used to directly sample phase space.</p>"},{"location":"program/canonical_configuration/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--temperature value</code>, <code>-t value</code>     default value 300     Temperature to emulate</p> </li> <li> <p><code>--nconf value</code>, <code>-n value</code>     default value 5     Number of configurations to generate</p> </li> <li> <p><code>--quantum</code>     default value .false.     Use Bose-Einstein statistics instead of Maxwell-Boltzmann. That is, use \\( \\sqrt{\\frac{\\hbar (2n+1) }{2 m \\omega}} \\) as the mean normal mode amplitudes instead of the classical \\( \\frac{1}{\\omega}\\sqrt{\\frac{k_BT}{m}} \\)</p> </li> <li> <p><code>--output_format value</code>, <code>-of value</code>, value in: <code>1,2,3,4,5</code>     default value 1     Selects output format. 1 is VASP, 2 is Abinit, 3 is LAMMPS, 4 is FHI-Aims, 5 is Siesta. Default 1.</p> </li> <li> <p><code>--mindist value</code>     default value -1     What is the smallest distance between two atoms allowed, in units of the nearest neighbour distance.</p> </li> <li> <p><code>--debye_temperature value</code>, <code>-td value</code>     default value -1     Generate forceconstants that match a Debye temperature, and build displacements according to these. See details below.</p> </li> <li> <p><code>--maximum_frequency value</code>, <code>-mf value</code>     default value -1     Generate forceconstants that match a maximum frequency (in THz), and build displacements according to these. See details below.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/canonical_configuration/#examples","title":"Examples","text":"<p><code>canonical_configuration -n 10 -t 300</code> </p> <p><code>canonical_configuration -n 300 -t 0 --quantum</code> </p> <p><code>canonical_configuration -n 20 -t 10 --quantum --debye_temperature 400</code> </p>"},{"location":"program/canonical_configuration/#longer-summary","title":"Longer summary","text":"<p>This code takes a second order forceconstant and generates a supercell with the atoms displaced corresponding to a harmonic canonical ensemble. These configurations can be used directly, to generate force-displacement statistics to determine force constants and other thermal properties, or as the starting point for molecular dynamics.</p>"},{"location":"program/canonical_configuration/#background","title":"Background","text":"<p>Born-Oppenheimer molecular dynamics can be expensive for many reasons. Firstly, it requires supercells with more than 100 atoms. Secondly, computation of the electronic ground state at every time step is time consuming. Thirdly, the cell must be fully equilibrated. The precision of the calculations is statistically linked to the number of configurations used: any property \\(A\\) for which we want to calculate the ensemble average \\(\\langle A \\rangle\\) must be converged with respect to the number of uncorrelated time steps.</p> <p>To minimize the equilibration time, the simulation cell can be initialized to a thermally excited state by selecting initial atomic velocities and displacement amplitudes according to the Maxwell-Boltzmann1 or Bose - Einstein distributions.</p> <p>Starting with the equations of motion for the supercell (given harmonic force constants)</p> \\[ \\begin{equation} \\begin{pmatrix} m_1 \\ddot{\\mathbf{u}}_1 \\\\ m_2 \\ddot{\\mathbf{u}}_2 \\\\ \\vdots \\\\ m_{N_a} \\ddot{\\mathbf{u}}_{N_a} \\end{pmatrix}= \\begin{pmatrix} \\mathbf{\\Phi}_{11} &amp; \\mathbf{\\Phi}_{12} &amp; \\cdots &amp; \\mathbf{\\Phi}_{1N_a} \\\\ \\mathbf{\\Phi}_{21} &amp; \\mathbf{\\Phi}_{22} &amp; \\cdots &amp; \\mathbf{\\Phi}_{2N_a} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ \\mathbf{\\Phi}_{N_a1} &amp; \\mathbf{\\Phi}_{N_a2} &amp; \\cdots &amp; \\mathbf{\\Phi}_{N_aN_a} \\end{pmatrix} \\begin{pmatrix} \\mathbf{u}_1\\\\ \\mathbf{u}_2 \\\\ \\vdots \\\\ \\mathbf{u}_{N_a} \\\\ \\end{pmatrix} \\end{equation} \\] <p>we diagonalise these and get obtaining \\(3N_a\\) eigenvalues \\(\\omega^2_s\\) and eigenvectors \\(\\epsilon_s\\). In the given cell, we can use this normal mode transformation to express the instantaneous positions and velocities,</p> \\[ \\begin{align} u_i = &amp; \\sum_{s=1}^{3N_a} \\epsilon_{is} A_{is} \\sin( \\omega_s t+\\delta_s ) \\\\ \\dot{u}_i = &amp; \\sum_{s=1}^{3N_a} \\epsilon_{is} A_{is} \\omega_s \\cos( \\omega_s t+\\delta_s) \\end{align} \\] <p>This is identical to the transformation introduced in phonon dispersion relations, except that the masses are incorporated in the normal mode amplitudes. We also omit the choice of \\(\\mathbf{q}\\)-vector, since we are only interested in the modes that are commensurate with the supercell. This leads to the dynamical matrix being a real symmetric matrix, with real eigenvalues and real eigenvectors.</p> <p>The normal mode amplitudes \\(A_s\\) and the phase \\(\\delta_s\\) will be determined by the following boundary conditions: we require a set of positions and velocities that correspond to a canonical ensemble. We choose \\(A_s\\) so that they are normally distributed around their mean value and that each mode \\(s\\) should contribute, on average, \\(k_B T/2\\) to the internal energy. Then</p> \\[ \\begin{equation} \\langle A_{is} \\rangle = \\sqrt{\\frac{\\hbar (2n_s+1) }{2 m_i \\omega_s}} \\approx \\frac{1}{\\omega_s}\\sqrt{\\frac{k_BT}{m_i}}, \\end{equation} \\] <p>where the approximate result is in the classical limit, $\\hbar \\omega \\ll k_BT $. The appropriate distribution of atomic positions and velocities is given by,</p> \\[ \\begin{align} u_i &amp; = \\sum_{s=1}^{3N_a} \\epsilon_{is} \\langle A_{is} \\rangle \\sqrt{-2\\ln \\xi_1}\\sin 2\\pi\\xi_2 \\\\ \\dot{u}_i &amp; = \\sum_{s=1}^{3N_a} \\omega_s \\epsilon_{is} \\langle A_{is} \\rangle \\sqrt{-2\\ln \\xi_1}\\cos 2\\pi\\xi_2 \\end{align} \\] <p>Here, \\(0 \\lt \\xi_n \\lt 1\\), represents a uniform distribution of random numbers, which are transformed to a normal distribution using the standard Box-Muller transform.</p> <p>Choosing the mean amplitudes in the classical limit gives us a snapshot in time from a canonical Maxwell-Boltzmann ensemble (within the harmonic approximation), which results in a starting point that reduces the time until equilibration by orders of magnitude. Choosing a Bose-Einstein distribution of mean amplitudes and velocities instead allows us to sample phase space while including quantum thermal disorder at low temperatures.</p> <p>For applications where one does not need consecutive timesteps, the starting configurations generated by this can be used  by run several simultaneous instances of Born-Oppenheimer molecular dynamics with different random starting configurations, rather than running a single long instance. This strategy allows for parallelization of Born-Oppenheimer molecular dynamics with near perfect linear scaling, since the overhead of equilibration time is almost completely eliminated.</p> <p> </p> <p>This is illustrated in the plot above. This is the singular value decomposition of molecular dynamics trajectories. A single colored field corresponds to data from a single random initial starting configuration. The dimensions spanned per unit time is greatly increased by stitching together calculations from different initial configurations. That is, 10 MD runs of 1000 time steps explores phase space better than a single MD run of 10x1000 time steps.</p>"},{"location":"program/canonical_configuration/#matching-with-a-debye-temperature","title":"Matching with a Debye temperature","text":"<p>Up until this point we have assumed you have forceconstants to generate the normal mode displacements. If you don't, it's possible to guess them. The following procedure is used: assume a pair potential \\(U(r)\\) which obeys</p> \\[ \\begin{equation} \\frac{ \\partial U(r)}{\\partial r_{ij} }=0 \\end{equation} \\] <p>and</p> \\[ \\begin{equation} \\frac{ \\partial^2 U(r)}{\\partial r_{ij}^2 }=\\frac{\\alpha}{r_{ij}^4} \\end{equation} \\] <p>Here \\(r_{ij}\\) is a pair distance in the supercell. Forceconstants can be calculated analytically from a pair potential, in this case they are given by</p> \\[ \\begin{equation} \\mathbf{\\Phi}(r)= -\\frac{\\alpha}{r^6} \\begin{pmatrix} r_x^2 &amp; r_x r_y &amp; r_x r_z \\\\ r_x r_y &amp; r_y^2 &amp; r_y r_z \\\\ r_x r_z &amp; r_y r_z &amp; r_z^2 \\end{pmatrix} \\end{equation} \\] <p>By definition, this will always produce stable phonons with the correct symmetry. The parameter \\(\\alpha\\) is determined by numerically matching the zero-point motion of the phonons to a Debye temperature (option <code>--debyte_temperature</code>):</p> \\[ \\begin{equation} \\frac{1}{N} \\sum_i \\frac{\\hbar \\omega_i(\\alpha)}{2} = \\frac{9 k_B T_D}{8} \\end{equation} \\] <p>Or alternatively matching the maximum frequency to a reference value (option <code>--maximum_frequency</code>). Using actual forceconstants is of course better, but this procedure generates surprisingly good configurations. They generally hold a decent balance between kinetic and potential energy, and by virtue of that they will cut equilibration time by orders of magnitude in your molecular dynamics.</p>"},{"location":"program/canonical_configuration/#stochastic-sampling","title":"Stochastic sampling","text":"<p>Todo</p> <p>Link to the tutorial for stochastic sampling.</p>"},{"location":"program/canonical_configuration/#input-files","title":"Input files","text":"<ul> <li>infile.ucposcar</li> <li>infile.ssposcar (use generate structure to create one)</li> <li>infile.forceconstant (or use <code>--debye_temperature</code> as described above)</li> </ul>"},{"location":"program/canonical_configuration/#output-files","title":"Output files","text":"<p>The desired number of configurations are printed in VASP POSCAR format by default, but the <code>--output_format</code> option can provide output in a variety of formats.</p> <ul> <li>contcar_conf0001</li> <li>contcar_conf0002</li> <li>contcar_conf0003</li> <li>...</li> </ul> <p>In case you used a Debye temperature to generate the configurations, <code>outfile.fakeforceconstant</code> will be written. Use phonon dispersion relations to plot it and check that the frequencies are reasonable.</p> <ol> <li> <p>West, D., &amp; Estreicher, S. (2006). First-Principles Calculations of Vibrational Lifetimes and Decay Channels: Hydrogen-Related Modes in Si. Physical Review Letters, 96(11), 115504. \u21a9</p> </li> </ol>"},{"location":"program/convert_abinit_ddb_to_forceconstant/","title":"Convert abinit ddb to forceconstant","text":""},{"location":"program/convert_abinit_ddb_to_forceconstant/#short-description","title":"Short description","text":"<p>Generates \"outfile.ucposcar\" and \"outfile.forceconstant\" from abinit DDB files.</p>"},{"location":"program/convert_abinit_ddb_to_forceconstant/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--qpoint_grid value#1 value#2 value#3</code>, <code>-qg value#1 value#2 value#3</code>     default value -1 -1 -1     Phonon q-point mesh used in Abinit.</p> </li> <li> <p><code>--files value#1 [value#2...]</code>, <code>-f value#1 [value#2...]</code>     DDB filename.</p> </li> <li> <p><code>--truncate</code>     default value .false.     Truncate the realspace IFCs.</p> </li> <li> <p><code>--cutoff value</code>, <code>-rc value</code>     default value -1     Force a cutoff on the realspace ifcs.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version author: Olle Hellman display: none graph: none propname: convert abinit propnamelink: convert abinit {!man/convert_abinit_ddb_to_forceconstant.md!}</p> </li> </ul>"},{"location":"program/convert_abinit_ddb_to_forceconstant/#longer-summary","title":"Longer summary","text":"<p>This is a utility to convert Abinit DDB files to the TDEP forceconstant format. A short disclaimer should be that it is not trivial to figure out what information is written to the abinit DDB files by parsing the DDB file alone. The conversion script has been tested on hundreds of Abinit calculations, but your mileage might vary.</p> <p>The script will try to figure out the q-mesh used in the DFPT calculations automatically, but in case you used a shifted mesh, you might want to specify it manually, since the information about the q-mesh is not printed to the DDB file.</p> <p>@todo Add io</p>"},{"location":"program/crystal_structure_info/","title":"Crystal structure info","text":""},{"location":"program/crystal_structure_info/#short-description","title":"Short description","text":"<p>This code serves as a diagnostic tool to check that symmetry heuristics are working as they should. The code prints which Bravais lattice was identified, which high symmetry points in the BZ are inequivalent, and so on. The Brillouin zone and its irreducible wedges are printed to files as polyhedra for manual inspection, and the symmetry operations of the lattice can be printed.</p>"},{"location":"program/crystal_structure_info/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--printsymmetry</code>     default value .false.     Also prints the symmetry operations</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/crystal_structure_info/#examples","title":"Examples","text":"<p><code>crystal_structure_info</code> </p> <p><code>crystal_structure_info --printsymmetry</code> </p>"},{"location":"program/crystal_structure_info/#long-summary","title":"Long summary","text":"<p>This is mainly a diagnostic tool, to make sure that my heuristics are working as they should. For example, if you want to calculate fcc Al, and things look strange, run this code to make sure that the symmetry detection actually identifies it as fcc. As a bonus, the Brillouin zone and the irreducible wedge is printed to file, so that you can make figures like the one below.</p> <p> </p>"},{"location":"program/crystal_structure_info/#input-files","title":"Input files","text":"<ul> <li>infile.ucposcar</li> </ul>"},{"location":"program/crystal_structure_info/#output-files","title":"Output files","text":""},{"location":"program/crystal_structure_info/#outfilebrillouin_zonehdf5","title":"<code>outfile.brillouin_zone.hdf5</code>","text":"<p>This contains the information to produce the plot above. I did it with the following matlab snippet:</p> <pre><code>% read all the stuff\nfn='outfile.brillouin_zone.hdf5';\nzone_nodes=h5read(fn,'/zone_nodes')';\nwedge_nodes=h5read(fn,'/wedge_nodes')';\nnf=h5readatt(fn,'/','number_of_zone_faces');\nfor i=1:nf\nzone_faces{i}=h5read(fn,['/zone_face_' num2str(i)]);\nend\nnf=h5readatt(fn,'/','number_of_wedge_faces');\nfor i=1:nf\nwedge_faces{i}=h5read(fn,['/wedge_face_' num2str(i)]);\nend\nlabels=strsplit(h5readatt(fn,'/','wedge_node_labels'));\nfigure(1); clf; hold on; axis equal off; view(3); camlight;\ni=drawPolyhedron(zone_nodes,zone_faces);\nset(i,'facealpha',0.3)\nj=drawPolyhedron(wedge_nodes,wedge_faces);\nset(j,'facealpha',0.3,'facecolor','blue')\nfor i=1:length(labels)\ntext(wedge_nodes(i,1),wedge_nodes(i,2),wedge_nodes(i,3),labels{i})\nend\n</code></pre> <p>This requires the Geom3D package.</p>"},{"location":"program/crystal_structure_info/#outfileqpoints_dispersion","title":"<code>outfile.qpoints_dispersion</code>","text":"<p>This is a prototype version of infile.qpoints_dispersion, so that you don't have to start from nothing when changin the path. It can look like this:</p> <pre><code>FCC                         ! Bravais lattice type\n  100                       ! Number of points on each path\n    4                       ! Number paths between special points\nGM  X                       ! Starting and ending special point\nX   U                       !\nK   GM                      !\nGM  L                       !\n</code></pre>"},{"location":"program/extract_forceconstants/","title":"Extract forceconstants","text":""},{"location":"program/extract_forceconstants/#short-description","title":"Short description","text":"<p>The main algorithm of the TDEP method. Starting with a symmetry analysis, this code finds the irreducible representation of interatomic forceconstants and extracts them from position and force data.</p>"},{"location":"program/extract_forceconstants/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--secondorder_cutoff value</code>, <code>-rc2 value</code>     default value 5.0     Cutoff for the second order force constants</p> </li> <li> <p><code>--thirdorder_cutoff value</code>, <code>-rc3 value</code>     default value -1     mutually exclude \"--thirdorder_njump\"     Cutoff for the third order force constants</p> </li> <li> <p><code>--fourthorder_cutoff value</code>, <code>-rc4 value</code>     default value -1     mutually exclude \"--fourthorder_njump\"     Cutoff for the fourth order force constants</p> </li> <li> <p><code>--polar</code>     default value .false.     Add dipole-dipole corrections for polar materials.</p> </li> <li> <p><code>--stride value</code>, <code>-s value</code>     default value 1     Use every N configuration instead of all. Useful for long MD simulations with linearly dependent configurations.</p> </li> <li> <p><code>--firstorder</code>     default value .false.     Include the first order force constants. These can be used to find the finite temperature equilibrium structure.</p> </li> <li> <p><code>--temperature value</code>     default value -1     Temperature for self-consistent solver.</p> </li> <li> <p><code>--norotational</code>     default value .false.     Turn off imposing rotational invariance. Needed for 2D systems.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/extract_forceconstants/#examples","title":"Examples","text":"<p><code>extract_forceconstants -rc2 5.1</code> </p> <p><code>extract_forceconstants -rc2 4.5 -rc3 3.21</code> </p>"},{"location":"program/extract_forceconstants/#longer-summary","title":"Longer summary","text":"<p>Calculations of the interatomic force constants are the most important part of any lattice dynamics calculation as they are used to calculate many micro and macroscopic properties of the system, e.g. phonon, thermodynamic, and transport properties, etc. This codes takes sets of displacements and forces, and uses these to fit the coefficients in an effective lattice dynamical Hamiltonian. This is by no means a new idea.5 The main advantage of the TDEP method is in the implementation: it is numerically robust, well tested and general. It is not limited in order, nor limited to simple ordered systems.</p> <p>Todo</p> <p>Convergence plots</p> <p>Todo</p> <p>Explain graph-based representation of tensors</p> <p>Todo</p> <p>Explain residual fit</p>"},{"location":"program/extract_forceconstants/#new-outline","title":"New outline","text":"<ul> <li>How do you turn symmetries into something useful</li> <li>How do you write the least squares problem?<ul> <li>note on solver = 2</li> </ul> </li> </ul>"},{"location":"program/extract_forceconstants/#what-is-a-force-constant-model","title":"What is a force constant model","text":"<p>Interatomic force constants are a central quantity in the TDEP model. The idea is to express the Born-Oppenheimer potential energy surface as a low-order polynomial around some configuration of interest. A quick recap of lattice dynamical theory:6 a displacement \\(\\mathbf{u}\\) of an atom \\(i\\) from its ideal lattice position changes the potential energy of the lattice. Temperature disorders the lattice, causing all atoms to be displaced from their equilibrium positions; this effect can be modeled as a Taylor expansion of the potential energy contribution of the instantaneous positions of the atoms in the system, i.e. \\(U=U(\\{ \\mathbf{r} \\})\\). It is convenient to define the atomic positions as displacements \\(\\mathbf{u}\\) from their equilibrium positions \\(\\mathbf{R}_i+\\boldsymbol{\\tau}_i\\).</p> \\[ \\begin{equation} \\textbf{r}_i=\\mathbf{R}_i+\\boldsymbol{\\tau}_i+\\mathbf{u}_i. \\end{equation} \\] <p>\\(\\mathbf{R}_i\\) is a lattice vector and \\(\\boldsymbol{\\tau}_i\\) is the position in the unit cell. We can then expand the potential energy in terms of displacements as:</p> \\[ \\begin{equation} \\begin{split} U(\\{\\textbf{u}\\})=&amp; U_0+ \\sum_{i}\\sum_\\alpha \\Phi^\\alpha_{i} u^\\alpha_{i} + \\frac{1}{2!} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi^{\\alpha\\beta}_{ij} u^\\alpha_{i} u^\\beta_{j} + \\\\  + &amp; \\frac{1}{3!} \\sum_{ijk} \\sum_{\\alpha\\beta\\gamma} \\Phi^{\\alpha\\beta\\gamma}_{ijk} u^\\alpha_{i} u^\\beta_{j} u^\\gamma_{k}+ \\frac{1}{4!} \\sum_{ijkl} \\sum_{\\alpha\\beta\\gamma\\delta} \\Phi^{\\alpha\\beta\\gamma\\delta}_{ijkl} u^\\alpha_{i} u^\\beta_{j} u^\\gamma_{k} u^\\delta_{l} + \\ldots  \\end{split} \\end{equation} \\] <p>Here, \\(\\alpha\\beta\\gamma\\delta\\) are Cartesian indices and \\(U_0\\) is the potential energy of the static lattice. The coefficients of the Taylor expansion are the derivatives of the potential energy with respect to displacement and are called the Born-von K\u00e0rm\u00e0n force constants, which can be expressed as tensors of increasing rank:</p> \\[ \\begin{align} \\Phi^\\alpha_i &amp; = \\left. \\frac{\\partial U}{\\partial u_i^\\alpha} \\right|_{u=0} = 0 \\\\ \\Phi^{\\alpha\\beta}_{ij} &amp; = \\left. \\frac{\\partial^2 U}{\\partial u_i^\\alpha \\partial u_j^\\beta} \\right|_{u=0} \\\\ \\Phi^{\\alpha\\beta\\gamma}_{ijk} &amp; = \\left. \\frac{\\partial^3 U}{\\partial u_i^\\alpha \\partial u_j^\\beta \\partial u_k^\\gamma} \\right|_{u=0} \\\\ \\Phi^{\\alpha\\beta\\gamma\\delta}_{ijkl} &amp; = \\left. \\frac{\\partial^4 U}{\\partial u_i^\\alpha \\partial u_j^\\beta \\partial u_k^\\gamma \\partial u_l^\\delta} \\right|_{u=0} \\end{align} \\] <p>By increasing rank, the force constants of rank \\(n\\) represent \\(n\\)-body interactions, as illustrated in the diagram below:</p> <p> </p> <p>What differs in the TDEP method and the textbook definitions is that we do not consider the interaction tensors as a Taylor expansion, instead they are free parameters designed to best describe the system at elevated temperature. This is done via a fitting procedure that will be explained below, and prefaced with a short formal motivation. The main advantage of a force constant model over the raw Born-Oppenheimer potential energy surface is that once it is established a host of quantities can be determined -- detailed in all the other sections of this manual.</p>"},{"location":"program/extract_forceconstants/#motivation-for-least-squares-fitting-procedure","title":"Motivation for least squares fitting procedure","text":"<p>Let's take a few steps back. Suppose we have the correct Hamiltonian \\(H_1\\) then we can evaluate, but it involves a substantial computational effort. It is then beneficial to create a model Hamiltonian \\(H_0\\) that is as close as possible to \\(H_1\\), but is several orders of magnitude cheaper to deal with computationally.</p> <p>For now, I will call \\(H_1\\) the true Hamiltonian, and \\(H_0\\) the reference Hamiltonian. I assume we have the means to numerically evaluate \\(H_1\\), but doing so is expensive. In this context, any numerical evaluation of \\(H_0\\) is considered to have negligible cost. The task is to evaluate the best criteria to use for determining \\(H_0\\), using information from \\(H_1\\), such that \\(H_0\\) can be used to evaluate physical properties of the system in question. This idea has been around since forever, and this secontion is a short recap of all the historical efforts to do so.</p>"},{"location":"program/extract_forceconstants/#work","title":"Work","text":"<p>Not the kind you are supposed to be doing, but the kind you were supposed to pay attention to in class. I have already defined our two Hamiltonians, \\(H_0\\) and \\(H_1\\). We start by defining an alchemical coupling path between the two Hamiltonians:</p> \\[\\label{eq:kirkwood}     H(\\lambda) = (1-\\lambda) H_0 + \\lambda H_1 \\] <p>as a quantity to work with. The parameter \\(0&lt;\\lambda&lt;1\\) allows us to alchemically switch between the Hamiltonians, or viewed differently, apply work to/measure work done by the systemfrom \\(H_1\\) to \\(H_0\\) and vice versa. Per some textbook we know that</p> \\[ \\begin{equation}\\label{eq:workandstuff}     \\Delta F \\le W \\end{equation} \\] <p>the free energy difference is smaller than the work done by the system. Think this is where the term free energy comes from, the energy free to do work. The equality holds in the quasistatic limit, where the system is kept in equilibrium the whole time. This leads is to one way to determine the free energy, Kirkwood coupling:</p> \\[\\label{eq:termoint}     F_1-F_0 =     \\int_0^1 \\frac{\\partial F(\\lambda)}{\\partial \\lambda} d{\\lambda} =     \\int_0^1 \\left\\langle H_1-H_0 \\right\\rangle_{\\lambda} d{\\lambda} \\] <p>This is the same as \\(\\ref{eq:workandstuff}\\). Here I introduced a new notation:</p> \\[     \\left\\langle X \\right\\rangle_y = \\int X e^{ -\\beta H_y} d{\\vec{p}}d{\\vec{r}} \\] <p>That is, the angled brackets means configuration average with respect to Hamiltonian \\(y\\). Works quantum mechical as well, just replace the integral with \\(\\textrm{ln} \\textrm{tr}\\). Good homework exercise to show (just write down the classical partition function for \\(H(\\lambda)\\) and take the derivative w.r.t \\(\\lambda\\), and it falls out by itself, remembering that \\(F=-k_B T \\ln Z\\)).</p> <p>At this point we are not interested in performing the integration over \\(\\lambda\\), although it certainly is practically possible if one wants to. Rather we will use this  expression backwards, i.e. figure out a way to make \\(H_1-H_0\\) as small as possible, since then the difference in free energy should disappear. And we can do this in a rather neat way. Several ways actually, but they all lead to the same result.</p>"},{"location":"program/extract_forceconstants/#expand-along-alchemical-path","title":"Expand along alchemical path","text":"<p>First, we can expand \\(F(\\lambda)\\) around \\(\\lambda=0\\)</p> \\[ \\begin{equation} \\begin{split}     F(\\lambda) = &amp; F_0 +     \\left\\langle H_1-H_0 \\right\\rangle_0\\lambda + \\\\     &amp; \\beta     \\left(     \\left\\langle(H_1-H_0)^2 \\right\\rangle_0-\\left\\langle H_1-H_0 \\right\\rangle^2_{0}     \\right)\\lambda^2 + \\sum_{n=3}^{\\infty} \\frac{1}{n!} C_0^n \\lambda^n \\end{split} \\end{equation} \\] <p>And integrate this from \\(\\lambda=0\\) to \\(\\lambda=1\\) and arrive at</p> \\[ \\begin{equation} \\begin{split}     F_1 = &amp; F_0 +     \\left\\langle H_1-H_0 \\right\\rangle_0 + \\\\     &amp; \\frac{\\beta}{2}     \\left(     \\left\\langle(H_1-H_0)^2 \\right\\rangle_0-\\left\\langle H_1-H_0 \\right\\rangle^2_{0}     \\right) + \\sum_{n=3}^{\\infty} C_0^n \\end{split} \\end{equation} \\] <p>We can also expand around \\(\\lambda=1\\), and arrive at</p> \\[ \\begin{equation} \\begin{split}     F_0 = &amp; F_1 +     \\left\\langle H_1-H_0 \\right\\rangle_1 + \\\\     &amp; \\frac{\\beta}{2}     \\left(     \\left\\langle(H_1-H_0)^2 \\right\\rangle_1-\\left\\langle H_1-H_0 \\right\\rangle^2_{1}     \\right) + \\sum_{n=3}^{\\infty} C_1^n \\end{split} \\end{equation} \\] <p>Here the sum of \\(C_0^n\\) runs of all the cumulants of order 3 and higher, with measure \\(H_0\\) and \\(H_1\\), respectively. Alternatively, one could start from an alternative exact expression:</p> \\[ F_A = F_B - k_B T \\ln \\left\\langle \\exp(-\\beta(H_A-H_B)) \\right\\rangle \\] <p>And do a cumulant expansion and arrive at exactly the same expressions. This is by no means a new idea,423 and by tracing references backwards I ended up at Thiele semiinvariants from 1800-something but could not find the actual papers. Suffice to say that is established.</p>"},{"location":"program/extract_forceconstants/#constraining-the-free-energy","title":"Constraining the free energy","text":"<p>We then make use of the Gibbs-Bogoliubov inequality (unfairly named since that also seems to trace much further back in time) that states</p> \\[ F_1 \\le F_0 + \\left\\langle H_1-H_0 \\right\\rangle_0 \\] <p>or</p> \\[ F_0 \\ge F_1 + \\left\\langle H_1-H_0 \\right\\rangle_1 \\] <p>by simple relabelling of terms. If we now insert or expansion expressions into the inequalities we end up with</p> \\[ 0 \\le \\frac{2}{\\beta} \\sum_{n=3}^{\\infty} C_1^n \\le \\left\\langle(H_1-H_0)^2 \\right\\rangle_0-\\left\\langle H_1-H_0 \\right\\rangle^2_{0} \\] <p>and</p> \\[ 0 \\le \\frac{2}{\\beta} \\sum_{n=3}^{\\infty} C_1^n \\le \\left\\langle(H_1-H_0)^2 \\right\\rangle_1-\\left\\langle H_1-H_0 \\right\\rangle^2_{1} \\] <p>What this means is that the second term in the expansion is larger than the sum of all higher order terms. So, to minimize the difference in free energy between \\(H_0\\) and \\(H_1\\), we need to minimize the variance of the energy, either samples with the proper dynamics \\(\\langle\\rangle_1\\) or via approximate dynamics \\(\\langle\\rangle_0\\).</p>"},{"location":"program/extract_forceconstants/#conclusion","title":"Conclusion","text":"<p>What I sketched above is that the Gibbs-Bogoliubov inequality can be recast into the problem of minimizing variance between a model Hamiltonian and the exact Hamiltonian, and that you are free to choose which statistical measure to use -- the result will be variational with respect to the free energy. This serves as the formal motivation behind TDEP. One option is to run ab inito (path integral) molecular dynamics to sample the potential energy surface, that would correspond to using measure \\(\\langle\\rangle_1\\). The other option is to use self-consistent stochastic sampling, this corresponds to \\(\\langle\\rangle_1\\) and is equivalent to self-consistent phonons.</p> <p>The main benefit of the above is that instead of minimizing an expression that involves three free energy, we minimize an expression that only involves the internal energy which is a lot easier. And since it is a variance we are to minimize a least squares solution is the natural choice, the least squares solution is the minimum variance solution. The variance is the square you minimize.</p> <p>Admittedly, this is a rather rough sketch of a motivation, a far more rigorous treatment is given by Alois, Jose and Matt, but the conclusions are the same.</p> <p>Note</p> <p>Fix reference to mode coupling paper as soon as it's published properly.</p>"},{"location":"program/extract_forceconstants/#practical-procedure","title":"Practical procedure","text":"<p>Now that we have established that a least squares fit of a model Hamiltonian is in general a good idea we have to do it in practice. The first step is to simplify the problem using symmetry.</p>"},{"location":"program/extract_forceconstants/#force-constant-symmetries","title":"Force constant symmetries","text":"<p>Symmetry analysis allows us to greatly reduce the number of values needed to express the force constants and is therefore crucial for generalizing the TDEP to include higher order terms in the potential energy surface. The symmetries of the force constants are deduced from rotational and translational invariance of the system, in addition to the symmetries of the crystal itself. We start with the transposition symmetries, which is an invariance under the permutation of the indices:98</p> \\[ \\begin{align} \\Phi_{ij}^{\\alpha\\beta} &amp; = \\Phi_{ji}^{\\beta\\alpha} \\\\ \\Phi_{ijk}^{\\alpha\\beta\\gamma} &amp; = \\Phi_{jik}^{\\beta\\alpha\\gamma} = \\ldots \\\\ \\Phi_{ijkl}^{\\alpha\\beta\\gamma\\delta} &amp; = \\Phi_{jikl}^{\\alpha\\beta\\gamma\\delta} = \\ldots \\end{align} \\] <p>All lattices belong to one of the 230 lattice space groups. The force constants should be invariant under these symmetry operations. If two tensors are related by symmetry operation \\(S\\) their components are related as follows:</p> \\[ \\begin{align} \\Phi_{ij}^{\\alpha\\beta} &amp;= \\sum_{\\mu\\nu}\\Phi_{kl}^{\\mu\\nu} S^{\\mu\\alpha}S^{\\nu\\beta}  \\\\ \\Phi_{ijk}^{\\alpha\\beta\\gamma} &amp;= \\sum_{\\mu\\nu\\xi}\\Phi_{mno}^{\\mu\\nu\\xi} S^{\\mu\\alpha} S^{\\nu\\beta} S^{\\xi\\gamma}\\\\ \\Phi_{ijkl}^{\\alpha\\beta\\gamma\\delta} &amp;= \\sum_{\\mu\\nu\\xi\\kappa}\\Phi_{mnop}^{\\mu\\nu\\xi\\kappa} S^{\\mu\\alpha} S^{\\nu\\beta} S^{\\xi\\gamma} S^{\\kappa\\delta} \\,.\\\\ \\end{align} \\] <p>where \\(S^{\\alpha\\beta}\\) is the proper or improper rotation matrix of the symmetry operation \\(S\\). Naturally, this will also enforce the periodic nature of the lattice. Force constants also obey the translational invariance (acoustic sum rules):</p> \\[ \\begin{align} \\sum_j \\mathbf{\\Phi}_{ij} &amp; =0 \\quad \\forall\\, i \\\\ \\sum_k \\mathbf{\\Phi}_{ijk} &amp; =0 \\quad \\forall\\, i,j \\\\ \\sum_l \\mathbf{\\Phi}_{ijkl} &amp; =0 \\quad \\forall\\, i,j,k \\end{align} \\] <p>The rotational invariance gives</p> \\[ \\begin{align} \\sum_i \\Phi_i^\\alpha r_i^\\beta &amp; = \\sum_i \\Phi_i^\\beta r_i^\\alpha \\quad \\forall \\, \\alpha,\\beta \\\\ \\sum_j \\Phi_{ij}^{\\alpha\\beta} r_j^\\gamma + \\Phi_i^\\beta \\delta_{\\alpha\\gamma} &amp; = \\sum_j \\Phi_{ij}^{\\alpha\\gamma} r_j^\\beta + \\Phi_i^\\gamma \\delta_{\\alpha\\beta} \\quad \\forall \\, \\alpha,\\beta,\\gamma \\\\ \\sum_k \\Phi_{ijk}^{\\alpha\\beta\\gamma}r_k^\\lambda +  \\Phi_{ij}^{\\gamma\\beta} \\delta_{\\alpha\\lambda} + \\Phi_{ij}^{\\alpha\\gamma} \\delta_{\\beta\\lambda} &amp;= \\sum_k \\Phi_{ijk}^{\\alpha\\beta\\lambda}r_k^\\gamma +  \\Phi_{ij}^{\\lambda\\beta} \\delta_{\\alpha\\gamma} + \\Phi_{ij}^{\\alpha\\lambda} \\delta_{\\beta\\gamma} \\quad \\forall \\, \\alpha,\\beta,\\gamma,\\lambda \\\\ \\end{align} \\] <p>And finally, the Huang invariances</p> \\[ \\begin{align} [\\alpha\\beta,\\gamma\\lambda] &amp; = \\sum_{ij} \\Phi_{ij}^{\\alpha\\beta} r_{ij}^\\gamma r_{ij}^\\lambda \\\\ [\\alpha\\beta,\\gamma\\lambda] &amp; = [\\gamma\\lambda,\\alpha\\beta] \\end{align} \\] <p>ensure that the second order forceconstants, when taken to the long-wavelength limit, result in the correct number of elastic constants. For low-symmetry crystals the Hermitian character of the dynamical matrix is enforced:1413</p> \\[ \\begin{equation}     \\sum_{j \\ne i} \\Phi^{\\alpha\\beta}_{ij} = \\sum_{j \\ne i} \\Phi^{\\beta\\alpha}_{ij} \\quad \\forall\\, i \\end{equation} \\] <p>All the symmetry relations above are naturally satisfied by the force constants produced by this code. In particular, the rotational, Huang and Hermitian invariances are rarely enforced in the literature, but are crucial for a correct behavior.</p> <p>Note</p> <p>A word of caution for low-dimensional systems: the Huang invariances do not apply there. Consider graphene, it is difficult to define an elastic constant that corresponds to compression along the z-axis in a meaningful way. The short term solution is to temporarily switch them off via  the option <code>--nohuang</code>. The long term solution is to derive the proper invariances for a two-dimensional material, something I have not had the time to do.</p>"},{"location":"program/extract_forceconstants/#practical-use-of-symmetries","title":"Practical use of symmetries","text":"<p>The symmetry relations needs to be transformed to linear algebra to be of practical use. I will use the second order force constants as an example, but the procedure is general. First step is to flatten each \\(3 \\times 3\\) tensor into a \\(9 \\times 1\\) vector, and express each component of the tensor as a linear combination of some coefficients \\(x\\):</p> \\[ \\underbrace{\\mathbf{\\Phi}}_{9 \\times 1} = \\underbrace{\\mathbf{C}}_{9 \\times 1} \\underbrace{\\mathbf{x}}_{9 \\times 1} \\] <p>Suppose some (point) symmetry operators leave the tensor invariant, this can be expressed as</p> \\[ \\left(\\sum_i \\mathbf{S}_i \\otimes \\mathbf{S}_i - \\mathbf{I}\\right) \\mathbf{\\Phi} = 0 \\] <p>There is also transposition symmetry, which can be expressed as a permutation matrix \\(T\\):</p> \\[ \\left(\\mathbf{T} - \\mathbf{I}\\right) \\mathbf{\\Phi} = 0 \\] <p>In total, this can be expressed as</p> \\[ \\mathbf{A} = \\left(\\mathbf{T} - \\mathbf{I}\\right) + \\left(\\sum_i \\mathbf{S}_i \\otimes \\mathbf{S}_i - \\mathbf{I}\\right) \\] \\[ \\mathbf{A} \\mathbf{C} \\mathbf{x} = 0 \\] <p>the problem is now reduced to finding \\(\\mathbf{C}\\). We are not interested in the trivial solution \\(\\mathbf{C}=0\\), instead we seek a matrix \\(\\mathbf{C}\\) in the null space of \\(\\mathbf{A}\\). We find that by constructing</p> \\[ \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V} = A \\] \\[ \\mathbf{C} = \\sum_{\\Sigma_i = 0} \\mathbf{U}^T \\mathbf{V} \\] <p>The rank of \\(\\mathbf{C}\\) is the number of zero singular values of \\(\\mathbf{A}\\), i.e. the number of irreducible variables \\(\\mathbf{x}\\), resulting in</p> \\[ \\underbrace{\\mathbf{\\Phi}}_{9 \\times 1} = \\underbrace{\\mathbf{C}}_{9 \\times N_x} \\underbrace{\\mathbf{x}}_{N_x \\times 1} \\] <p>where \\(N_x \\le 9\\).</p>"},{"location":"program/extract_forceconstants/#practical-use-in-real-systems","title":"Practical use in real systems","text":"<p>We use a procedure near identical to what is described above. The starting point is a set of displacements \\(\\vec{u}\\) and forces \\(\\vec{f}\\) from a set of \\(N_c\\) supercells sampled from a canonical ensemble at temperature \\(T\\). Although omitted in the notation, all interaction tensors depend on temperature as well as the volume (or more generally strain). The interatomic force constants are determined as follows: consider a supercell with \\(N_a\\) atoms and forces and displacements given by the \\(3N_{a} \\times 1\\) vectors \\(\\vec{u}\\) and \\(\\vec{f}\\) (for clarity we will make note of the dimensions of the matrices in each step):</p> \\[     \\underbrace{\\vec{f}}_{3N_a \\times 1}     = -     \\underbrace{\\vec{\\Phi}}_{3N_a \\times 3 N_a}     \\underbrace{\\vec{u}}_{3N_a \\times 1} \\] <p>we can arrange this on a form with flattened tensors as</p> \\[     \\underbrace{\\vec{f}}_{3N_a \\times 1}     = -     \\underbrace{(\\vec{I} \\otimes \\vec{u}^T)}_{3N_a \\times (3N_a)^2}     \\underbrace{\\vec{\\Phi}_v}_{ (3N_a)^2 \\times 1} \\] <p>with the Kronecker product \\(\\otimes\\). To express the forces from \\(N_c\\) supercells the matrices are stacked on top of each other:</p> \\[     \\underbrace{     \\begin{pmatrix}         \\vec{f}_1 \\\\         \\vdots \\\\         \\vec{f}_{N_c}     \\end{pmatrix}     }_{3N_a N_c \\times 1}     = -     \\underbrace{     \\begin{pmatrix}         \\vec{I} \\otimes \\vec{u}_1^T \\\\         \\vdots \\\\         \\vec{I} \\otimes \\vec{u}_{N_c}^T \\\\     \\end{pmatrix}     }_{3N_aN_c \\times (3N_a)^2}     \\underbrace{\\vec{\\Phi}_v}_{ (3N_a)^2 \\times 1} \\] <p>We then express the force constants via the irreducible components</p> \\[     \\underbrace{     \\begin{pmatrix}         \\vec{f}_1 \\\\         \\vdots \\\\         \\vec{f}_{N_c}     \\end{pmatrix}     }_{3N_a N_c \\times 1}     = -     \\underbrace{     \\underbrace{     \\begin{pmatrix}         \\vec{I} \\otimes \\vec{u}_1^T \\\\         \\vdots \\\\         \\vec{I} \\otimes \\vec{u}_{N_c}^T \\\\     \\end{pmatrix}     }_{3N_aN_c \\times (3N_a)^2}     \\underbrace{     \\vec{C}^{\\Phi\\textrm{II}}     }_{(3N_a)^2 \\times N_x}     }_{=\\vec{A}^{\\Phi\\textrm{II}}\\,, 3N_a N_c \\times N_x }     \\underbrace{\\vec{x}^{\\Phi\\textrm{II}}}_{ N_x \\times 1} \\] <p>The set of symmetry relations and invariances determines \\(\\vec{C}\\) and \\(N_x\\),~\\cite{Leibfried1961,Maradudin1968,Born1998} and in general \\(N_x \\ll (3N_a)^2\\) which considerably simplifies the problem of numerically determining \\(\\vec{\\Phi}\\). In practice, only the matrix \\(\\vec{A}\\) is determined and stored. The nominally very large matrices that go into the construction of \\(\\vec{A}\\) are quite sparse and construction presents negligible computational cost. The second order force constants imply matrices that could possibly be treated naively, but the generalization to higher order quickly becomes intractable with dense matrix storage. The third order force constants, for example, comes down to</p> \\[     \\underbrace{     \\begin{pmatrix}         \\vec{f}_1 \\\\         \\vdots \\\\         \\vec{f}_{N_c}     \\end{pmatrix}     }_{3N_a N_c \\times 1}      = -     \\underbrace{     \\underbrace{     \\begin{pmatrix}         \\vec{I} \\otimes \\vec{u}_1^T \\otimes \\vec{u}_1^T\\\\         \\vdots \\\\         \\vec{I} \\otimes \\vec{u}_{N_c}^T \\otimes \\vec{u}_{N_c}^T \\\\     \\end{pmatrix}     }_{3N_aN_c \\times (3N_a)^3}     \\underbrace{     \\vec{C}^{\\Phi\\textrm{III}}     }_{(3N_a)^3 \\times N_x}     }_{=\\vec{A}^{\\Phi\\textrm{III}}\\,, 3N_a N_c \\times N_x }     \\underbrace{\\vec{x}^{\\Phi\\textrm{III}}}_{ N_x \\times 1} \\] <p>where the contracted matrix \\(\\vec{A}\\) is many orders of magnitude smaller than the matrices it is built from.</p> <p>The interatomic force constants are determined in succession:</p> \\[ \\begin{align} \\label{eq:f2}     \\vec{A}^{\\Phi\\textrm{II}}     \\vec{x}^{\\Phi\\textrm{II}} &amp; = \\vec{f} % \\\\ % \\label{eq:f3}     \\vec{A}^{\\Phi\\textrm{III}}     \\vec{x}^{\\Phi\\textrm{III}} &amp; =     \\vec{f}-     \\vec{A}^{\\Phi\\textrm{II}}     \\vec{x}^{\\Phi\\textrm{II}} % \\\\ % \\label{eq:f4}     \\vec{A}^{\\Phi\\textrm{IV}}     \\vec{x}^{\\Phi\\textrm{IV}} &amp; =     \\vec{f}     -     \\vec{A}^{\\Phi\\textrm{II}}     \\vec{x}^{\\Phi\\textrm{II}}     -     \\vec{A}^{\\Phi\\textrm{III}}     \\vec{x}^{\\Phi\\textrm{III}} \\end{align} \\] <p>Where \\(\\vec{f}\\) denotes the reference forces to be reproduced. Equations \\(\\ref{eq:f2}-\\ref{eq:f4}\\) are overdetermined and solved as a least squares problem. This ensures that the baseline harmonic part becomes as large as possible, and that the higher order terms become smaller and smaller. Some of the symmetry constraints are cumbersome to implement as linear operators, they are instead implemented as linear constraints. So for a low symmetry crystal the least squares problem is stated as</p> \\[     \\vec{A}^{\\Phi\\textrm{II}}     \\vec{x}^{\\Phi\\textrm{II}} = \\vec{f} \\quad \\textrm{subject to} \\quad \\vec{B}\\vec{x}^{\\Phi\\textrm{II}}=0 \\]"},{"location":"program/extract_forceconstants/#on-dynamical-stability-and-stochastic-sampling","title":"On dynamical stability and stochastic sampling","text":"<p>Note</p> <p>add link to stochastic sampling tutorial once it is prepared</p> <p>As we established above we can either sample the potential energy surface via some variant of molecular dynamics/Monte Carlo simulations per the true Hamiltonian, or sample using the force constant model. Sampling with the force constant model collapses in case any eigenvalue of the dynamical matrix is negative - in that case no free energy is defined. One generally states self-consistent phonon theory as minimization of \\(F_0 + \\left\\langle H_1 -H_0 \\right\\rangle_0\\) with respect to the parameters in the model Hamiltonian. This is a slight simplification, since the symmetry constraints from the space group imply a reduced search space, some symmetry constraints imply additional equality constraints and on top of that we have the requirement of positive semi-definite eigenvalues.</p> <p>Let's start from the naive least squares problem:</p> \\[     \\min_{\\phi} \\left\\| F - U \\Phi  \\right\\|^2 \\] <p>We use the same flattening technique as previously and can rewrite the least squares problem (by expanding the square) as</p> \\[     \\min_{\\phi} \\vec{\\Phi_v}^T \\left[\\tilde{\\vec{U}}^T\\otimes\\tilde{\\vec{U}}\\right] \\vec{\\Phi_v}     -     \\vec{\\Phi_v}^T \\left[\\vec{I}\\otimes\\tilde{\\vec{U}}\\right]^T \\vec{F}_v \\,. \\] <p>The next step is to again express the force constants in terms of their irreducible components, and remember that we have some linear constraints:</p> \\[ \\begin{align}     \\vec{x} &amp; = \\min_{\\vec{x}}\\,     \\vec{x}^T \\vec{D} \\vec{x}     -     \\vec{x}^T \\vec{d} \\quad \\textrm{s.t.} \\quad \\vec{B}\\vec{x}=0 \\\\     \\vec{D} &amp; = \\vec{C}^T \\left[\\tilde{\\vec{U}}^T\\otimes\\tilde{\\vec{U}}\\right] \\vec{C} = \\vec{A^T}\\vec{A} \\\\     \\vec{d} &amp; = \\vec{C}^T \\left[\\vec{I}\\otimes\\tilde{\\vec{U}}\\right]^T \\vec{F}_v = \\vec{A}^T \\vec{F} \\end{align} \\] <p>The main difficulty lies in the constraint that the dynamical matrix needs to be positive semi-definite. This constraint can be states as</p> \\[     \\vec{s}^T \\Phi \\vec{s} &gt; 0 \\] <p>for any vector \\(\\vec{s}\\), i.e. there is no combination of displacements that lower the energy below the baseline. In our flattened and irreducible form this becomes</p> \\[     \\vec{s} \\otimes \\vec{s} \\vec{C} \\vec{x} &gt; 0 \\] <p>Luckily, this is a solved problem.7 The algorithm progresses as follows: first we solve</p> \\[     \\vec{x} = \\min_{\\vec{x}}\\,     \\vec{x}^T \\vec{D} \\vec{x}     -     \\vec{x}^T \\vec{d} \\quad \\textrm{s.t.} \\quad \\vec{B}\\vec{x}=0 \\, \\] <p>and construct \\(\\Phi\\), and examine the eigenvalues. If all eigenvalues are positive, we are done. If not, all the eigenvectors corresponding to negative eigenvalues are added as inequality constraints:</p> \\[     \\vec{E} = \\left( \\epsilon_1 \\otimes \\epsilon_1 \\cdots \\epsilon_N \\otimes \\epsilon_N  \\right)\\vec{C} \\] <p>and we get a new quadratic program</p> \\[     \\vec{x} = \\min_{\\vec{x}}\\,     \\vec{x}^T \\vec{D} \\vec{x}     -     \\vec{x}^T \\vec{d} \\quad \\textrm{s.t.} \\quad \\vec{B}\\vec{x}=0 \\quad \\textrm{and} \\quad \\vec{E}\\vec{x} &gt; \\alpha \\] <p>where \\(\\alpha\\) is a small positive number. We again calculate the eigenvalues of \\(\\Phi\\), and if any new negative eigenvalues emerge the matrix \\(\\vec{E}\\) gets appended and the process is repeated until all eigenvalues are positive. The sequence of quadratic programs are solved with an interior method.[CITE]</p> <p>This is a numerically robust formulation of self-consistent phonons, but it must be mentioned that it is rarely needed. If you are simulating materials that are known to exist, they rarely show negative eigenvalues if the numerics are well-converged. The option to use the positive definite solver is available (<code>--solver 2</code>), but if you need to use it odds are high that it is in fact the numerics/convergence that is the actual issue. Which is why the option is this deep in the documentation, if you bothered to read this far you probably took the time to understand how to get the numerics correct as well.</p>"},{"location":"program/extract_forceconstants/#how-to-test-if-things-are-converged","title":"How to test if things are converged","text":"<p>Note</p> <p>Add link to tutorial, better covered there.</p>"},{"location":"program/extract_forceconstants/#input-files","title":"Input files","text":"<ul> <li>infile.ucposcar</li> <li>infile.ssposcar</li> <li>infile.meta</li> <li>infile.stat</li> <li>infile.positions</li> <li>infile.forces</li> </ul>"},{"location":"program/extract_forceconstants/#output-files","title":"Output files","text":""},{"location":"program/extract_forceconstants/#outfileforceconstant","title":"<code>outfile.forceconstant</code>","text":"<p>This is the second order force constant, in a plain text format. Schematically, it contains a list of pairs originating from each atom in the unit cell. Once generated, any association with a specific simulation supercell is lost. The file looks something like this:</p> <pre><code>          2               How many atoms per unit cell\n    4.107441758929446     Realspace cutoff (A)\n         19               How many neighbours does atom   1 have\n          2               In the unit cell, what is the index of neighbour  1 of atom  1\n  -1.0000000000000000       -1.0000000000000000        0.0000000000000000\n -0.22399077464508912        0.0000000000000000        0.0000000000000000\n   0.0000000000000000      -0.22399077464508918        0.0000000000000000\n   0.0000000000000000        0.0000000000000000       -1.3582546804397253\n          2               In the unit cell, what is the index of neighbour  2 of atom  1\n  -1.0000000000000000        0.0000000000000000       -1.0000000000000000\n -0.22399077464508912        0.0000000000000000        0.0000000000000000\n   0.0000000000000000       -1.3582546804397253        0.0000000000000000\n   0.0000000000000000        0.0000000000000000      -0.22399077464508918\n          1               In the unit cell, what is the index of neighbour  3 of atom  1\n  -1.0000000000000000        0.0000000000000000        0.0000000000000000\n   6.5363921282622556E-002   0.0000000000000000        0.0000000000000000\n   0.0000000000000000      -0.14683417732241597      -0.62709958702233359\n   0.0000000000000000      -0.62709958702233382      -0.14683417732241599\n          2               In the unit cell, what is the index of neighbour  4 of atom  1\n...\n...\n...\n</code></pre> <p>The content of the file is pretty straightforward. The header is two lines, the number of atoms in the unit cell and the realspace cutoff (in \u00c5). Next we have repeating units for each pair of atoms. We start from atom 1, with a note how many pairs are included for atom 1. Then for each of those pairs we note what is the index of the other atom in the pair, what is the lattice vector (in fractional coordinates) that locate the unit cell of that atom, followed by the \\(3 \\times 3\\) tensor (in Carteisian coordinates, eV/\u00c5^2). This is repeated for neighbours of atom one, and then on to the next atom and so on.</p>"},{"location":"program/extract_forceconstants/#outfileforceconstant_thirdorder","title":"<code>outfile.forceconstant_thirdorder</code>","text":"<p>The format for this file is similar to the second order:</p> <ol> <li> <p>J. G. Kirkwood (1935), The Journal of Chemical Physics 3, 300\u00a0\u21a9</p> </li> <li> <p>A. Isihara (1968), Journal of Physics A: General Physics 1, 305\u00a0\u21a9</p> </li> <li> <p>J. W. Gibbs (1902), Elementary Principles in Statistical Mechanics: Developed with Especial Reference to the Rational Foundations of Thermodynamics,  C. Scribner\u2019s sons\u00a0\u21a9</p> </li> <li> <p>H. D. Ursell (1927), Mathematical Proceedings of the Cambridge Philosophical Society 23, 685\u00a0\u21a9</p> </li> <li> <p>Klein, M. L., &amp; Horton, G. K. (1972). The rise of self-consistent phonon theory. Journal of Low Temperature Physics, 9(3-4), 151\u2013166. \u21a9</p> </li> <li> <p>Born, M., &amp; Huang, K. (1964). Dynamical theory of crystal lattices. Oxford: Oxford University Press.\u00a0\u21a9</p> </li> <li> <p>H. Hu (1995), Linear Algebra and its Applications 229, 167\u00a0\u21a9</p> </li> <li> <p>Maradudin, A. A., &amp; Vosko, S. (1968). Symmetry Properties of the Normal Vibrations of a Crystal. Reviews of Modern Physics, 40(1), 1\u201337. \u21a9</p> </li> <li> <p>Leibfried, G., &amp; Ludwig, W. (1961). Theory of Anharmonic Effects in Crystals. Solid State Physics - Advances in Research and Applications, 12(C), 275\u2013444. \u21a9</p> </li> <li> <p>Hellman, O., Abrikosov, I. A., &amp; Simak, S. I. (2011). Lattice dynamics of anharmonic solids from first principles. Physical Review B, 84(18), 180301. \u21a9</p> </li> <li> <p>Hellman, O., &amp; Abrikosov, I. A. (2013). Temperature-dependent effective third-order interatomic force constants from first principles. Physical Review B, 88(14), 144301. \u21a9</p> </li> <li> <p>Hellman, O., Steneteg, P., Abrikosov, I. A., &amp; Simak, S. I. (2013). Temperature dependent effective potential method for accurate free energy calculations of solids. Physical Review B, 87(10), 104111. \u21a9</p> </li> <li> <p>Scheringer, C. The Hermiticity of the dynamical matrix. Acta Crystallogr. Sect. A 30, 295\u2013295 (1974). \u21a9</p> </li> <li> <p>Martin, R. M. Hermitian character of the dynamical matrix - a comment on \u2018non-hermitian dynamical matrices in the dynamics of low symmetry crystals\u2019. Solid State Commun. 9, 2269\u20132270 (1971). \u21a9</p> </li> </ol>"},{"location":"program/generate_structure/","title":"Generate structure","text":""},{"location":"program/generate_structure/#short-description","title":"Short description","text":"<p>Builds supercells, diagonal and non-diagonal. Also has the capability to find the optimal supercells for a given lattice, very handy when you have complicated structures.</p>"},{"location":"program/generate_structure/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--dimensions value#1 value#2 value#3</code>, <code>-d value#1 value#2 value#3</code>     default value 5 5 5     Dimensions of supercell.</p> </li> <li> <p><code>--nondiagonal_dimensions value#1 value#2 value#3 value#4 value#5 value#6 value#7 value#8 value#9</code>, <code>-nd value#1 value#2 value#3 value#4 value#5 value#6 value#7 value#8 value#9</code>     default value 0 0 0 0 0 0 0 0 0     Non-diagonal dimensions of supercell.</p> </li> <li> <p><code>--output_format value</code>, <code>-of value</code>, value in: <code>1,2,3,4,5</code>     default value 1     Output format. 1 is VASP, 2 Abinit, 3 LAMMPS, 4 FHI-Aims and 5 Siesta</p> </li> <li> <p><code>--desired_na value</code>, <code>-na value</code>     default value -1     Desired number of atoms in supercell. Will try to choose a cell as cubic as possible.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/generate_structure/#examples","title":"Examples","text":"<p><code>generate_structure -dim 4 3 5</code> </p> <p><code>generate_structure -na 200</code> </p>"},{"location":"program/generate_structure/#longer-summary","title":"Longer summary","text":"<p>This code builds a supercell with user-specified dimensions from the unit cell given in <code>infile.ucposcar</code>. All positions are in fractional coordinates.</p> <p>The code handles diagonal and non-diagonal cells. The diagonal cells are simple repetitions of the unit cell, making it \\(N_1 \\times N_2 \\times N_3\\) larger. The non-diagonal cells can be useful when the unit cell has an awkward shape. The supercell will have the lattice vectors</p> \\[ \\begin{pmatrix} \\mathbf{A}_1 \\\\ \\mathbf{A}_2 \\\\ \\mathbf{A}_3 \\\\ \\end{pmatrix} = \\mathbf{M} \\begin{pmatrix} \\mathbf{a}_1 \\\\ \\mathbf{a}_2 \\\\ \\mathbf{a}_3 \\end{pmatrix} \\] <p>where \\(\\det( \\mathbf{M} )\\) is a positive integer. Some useful transformations are, for example, with <code>-nd -n1 n1 n1 n2 -n2 n2 n3 n3 -n3</code>, from a primitive fcc lattice to the conventional cubic</p> \\[ \\begin{pmatrix} n_1 a &amp; 0 &amp; 0 \\\\ 0 &amp; n_2 a &amp; 0 \\\\ 0 &amp; 0 &amp; n_3 a \\end{pmatrix} =\\begin{pmatrix} -n_1 &amp; n_1 &amp; n_1 \\\\ n_2 &amp; -n_2 &amp; n_2 \\\\ n_3 &amp; n_3 &amp; -n_3 \\end{pmatrix} \\begin{pmatrix} 0 &amp; a/2 &amp; a/2 \\\\ a/2 &amp; 0 &amp; a/2 \\\\ a/2 &amp; a/2 &amp; 0 \\end{pmatrix} \\] <p>Similarly, from a primitive bcc to conventional cubic:</p> \\[ \\begin{pmatrix} n_1 a &amp; 0 &amp; 0 \\\\ 0 &amp; n_2 a &amp; 0 \\\\ 0 &amp; 0 &amp; n_3 a \\end{pmatrix} =\\begin{pmatrix} 0 &amp; n_1 &amp; n_1 \\\\ n_2 &amp; 0 &amp; n_2 \\\\ n_3 &amp; n_3 &amp; 0 \\end{pmatrix} \\begin{pmatrix} -a/2 &amp; a/2 &amp; a/2 \\\\ a/2 &amp; -a/2 &amp; a/2 \\\\ a/2 &amp; a/2 &amp; -a/2 \\end{pmatrix} \\] <p>There are some non-obvious ones as well, such as converting a hexagonal lattice to an orthorhombic:</p> \\[ \\begin{pmatrix} n_1 a &amp; 0 &amp; 0 \\\\ 0 &amp; \\sqrt{3} n_2 a  &amp; 0 \\\\ 0 &amp; 0 &amp; n_3 c \\end{pmatrix} =\\begin{pmatrix} n_1 &amp; n_1 &amp; 0 \\\\ -n_2 &amp; n_2 &amp; 0 \\\\ 0 &amp; 0 &amp; n_3 \\end{pmatrix} \\begin{pmatrix} a/2 &amp; -a\\sqrt{3}/2 &amp; 0 \\\\ a/2 &amp; a \\sqrt{3}/2 &amp; 0 \\\\ 0 &amp; 0 &amp; c \\end{pmatrix} \\] <p>or rhombohedral (lattice parameter \\(a\\), angle \\(\\alpha\\)) to hexagonal:</p> \\[ \\begin{equation*} \\begin{split} \\begin{pmatrix} 0 &amp; n_1 a \\sqrt{2-2 \\cos\\alpha} &amp; 0  \\\\ -n_2 a\\sqrt{ \\frac{2-2 \\cos\\alpha}{3} } &amp; -n_2 a \\sqrt{2-2 \\cos\\alpha}  &amp; 0 \\\\ 0 &amp; 0 &amp; n_3 a \\sqrt{3+6\\cos\\alpha} \\end{pmatrix} = \\\\ \\\\ \\begin{pmatrix} n_1 &amp; n_1 &amp; 0 \\\\ -n_2 &amp; n_2 &amp; 0 \\\\ 0 &amp; 0 &amp; n_3 \\end{pmatrix} \\begin{pmatrix} a\\sqrt{2-2\\cos\\alpha} &amp; 0 &amp; a\\sqrt{\\frac{1+2\\cos\\alpha}{3}} \\\\ -a\\sqrt{\\frac{1-\\cos\\alpha}{2}} &amp; a\\sqrt{3\\frac{1-\\cos\\alpha}{2}} &amp; a\\sqrt{\\frac{1+2\\cos\\alpha}{3}} \\\\ -a\\sqrt{\\frac{1-\\cos\\alpha}{2}} &amp; -a\\sqrt{3\\frac{1-\\cos\\alpha}{2}} &amp; a\\sqrt{\\frac{1+2\\cos\\alpha}{3}} \\end{pmatrix} \\end{split} \\end{equation*} \\] <p>There are too many ways to build supercells to list here. The examples are suggestions so that you can pick a supercell that is as cubic as possible. Converging results with respect to supercell size goes approximately as the size of the largest sphere you can fit in the cell.</p>"},{"location":"program/generate_structure/#automatic-generation","title":"Automatic generation","text":"<p>The option <code>-na</code> will try to determine a non-diagonal supercell that is as cubic as possible, with the number of atoms close to the specified value. It does it by generating a massive amount of possible supercell transformation matrices, and comparing the ratio of the cell volume and the volume of the inscribed sphere. By optimizing with respect to this ratio, a reasonably cubic cell should be the result. Very useful when you have a unitcell with a tricky shape and it's non-trivial to figure out a meaningful transformation matrix.</p> <p>To clarify, a cell defined by vectors \\(\\mathbf{a}\\), \\(\\mathbf{b}\\) and \\(\\mathbf{c}\\) will have the volume</p> \\[ V=\\left|\\det \\begin{pmatrix}   a_x &amp; a_y &amp; a_z \\\\   b_x &amp; b_y &amp; b_z \\\\   c_x &amp; c_y &amp; c_z \\end{pmatrix}\\right| \\] <p>In the same cell, the radius of the largest sphere that can be inscribed is given by</p> \\[ 2r=\\min\\left\\{ \\left|\\frac{ \\mathbf{b} \\times \\mathbf{c} }{\\left| \\mathbf{b} \\times \\mathbf{c} \\right|}\\cdot \\mathbf{a}\\right| \\,,\\quad \\left|\\frac{ \\mathbf{a} \\times \\mathbf{b} }{\\left| \\mathbf{a} \\times \\mathbf{b} \\right|}\\cdot \\mathbf{c}\\right| \\,,\\quad \\left|\\frac{ \\mathbf{a} \\times \\mathbf{c} }{\\left| \\mathbf{a} \\times \\mathbf{c} \\right|}\\cdot \\mathbf{b}\\right| \\right\\} \\] <p>I define the ratio</p> \\[ f^3 = \\frac{r^3 4 \\pi}{3V} \\le 1 \\] <p>As the function to be maximized (it is the ratio of the filling ratio of a cell and the filling ratio of a cube with the same volume, a value of 1 indicates a perfect cube). The algorithm works by searching the space of non-diagonal supercell matrices that produce approximately the desired number of atoms and simultaneously maximize the filling ratio. This algorithm produces rather non-intuitive cells. Consider Bi2Te3 defined in the primitive rhombohedral cell:</p> <pre><code>Bi2Te3\n  10.314046162\n 0.243360208934  0.000000000000  0.969935981757\n-0.121680104467  0.210756123207  0.969935981757\n-0.121680104467 -0.210756123207  0.969935981757\nBi Te\n2 3\ndirect coordinates\n 0.599898812406  0.599898812406  0.599898812406 site: 1\n 0.400101187594  0.400101187594  0.400101187594 site: 2\n 0.791308614612  0.791308614612  0.791308614612 site: 3\n 0.208691385388  0.208691385388  0.208691385388 site: 4\n 0.000000000000  0.000000000000  0.000000000000 site: 5\n</code></pre> <p>Using this algorithm I found the supercell matrix</p> \\[ M=\\begin{pmatrix} 3 &amp; 2 &amp; -4 \\\\ 4 &amp; -3 &amp; -2 \\\\ -2 &amp; 4 &amp; -3 \\end{pmatrix} \\] <p>that produce the lattice vectors</p> <p><pre><code>Bi2Te3 upercell\n      10.314046161996\n    0.97344083573636     1.26453673924247     0.96993598175736\n    1.58184135807159    -0.21075612320708    -0.96993598175736\n   -0.60840052233523     1.47529286244955    -0.96993598175736\n Bi Te\n 86 129\n</code></pre> This cell has a filling ratio corresponding to 98.4% of the ideal cube.</p>"},{"location":"program/generate_structure/#input-files","title":"Input files","text":"<ul> <li>infile.ucposcar</li> </ul>"},{"location":"program/generate_structure/#output-files","title":"Output files","text":"<ul> <li>outfile.ssposcar</li> </ul>"},{"location":"program/lineshape/","title":"Lineshape","text":""},{"location":"program/lineshape/#short-description","title":"Short description","text":"<p>Calculate the frequency-dependent self-energy and phonon spectral function.</p>"},{"location":"program/lineshape/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--unit value</code>, value in: <code>thz,mev,icm</code>     default value thz     Choose the output unit. The options are terahertz (in frequency, not angular frequency), inverse cm or meV.</p> </li> <li> <p><code>--temperature value</code>     default value 300     Temperature used in the occupation numbers. Should be the same as the temperature the force constants where determined at.</p> </li> <li> <p><code>--n_energies value</code>, <code>-ne value</code>     default value 1200     Number of energies for the energy-dependent self-energy.</p> </li> <li> <p><code>--qpoint_grid value#1 value#2 value#3</code>, <code>-qg value#1 value#2 value#3</code>     default value 26 26 26     Density of q-point mesh for Brillouin zone integrations.</p> </li> <li> <p><code>--meshtype value</code>, value in: <code>1,2,3</code>     default value 2     Type of q-point mesh. 1 Is a Monkhorst-Pack mesh, 2 an FFT mesh and 3 my fancy wedge-based mesh with approximately the same density the grid-based meshes. 4 build the commensurate mesh of an approximately cubic supercell.</p> </li> <li> <p><code>--integrationtype value</code>, <code>-it value</code>, value in: <code>1,2,3,4,5</code>     default value 2     Type of integration for phase space integrals. 1 is Gaussian, 2 adaptive Gaussian and 3 Tetrahedron.</p> </li> <li> <p><code>--sigma value</code>     default value 1.0     Global scaling factor for Gaussian/adaptive Gaussian smearing. The default is determined procedurally, and scaled by this number.</p> </li> <li> <p><code>--path</code>     default value .false.     Calculate the self-energy and spectral function on a path through the BZ.</p> </li> <li> <p><code>--readpath</code>, <code>-rp</code>     default value .false.     Read the q-point path from <code>infile.qpoints_dispersion</code>. Use crystal structure into to generate an example.</p> </li> <li> <p><code>--nq_on_path value</code>, <code>-nq value</code>     default value 100     Number of q-points between each high symmetry point</p> </li> <li> <p><code>--dos</code>     default value .false.     Calculate the broadened and shifted phonon DOS.</p> </li> <li> <p><code>--dos_qpoint_grid value#1 value#2 value#3</code>     default value -1 -1 -1     Interpolate to a (preferrably) denser q-mesh when calculating the DOS.</p> </li> <li> <p><code>--qpoint value#1 value#2 value#3</code>     default value 0 0 0     Calculate the self-energy at a single q-point, input in fractional coordinates.</p> </li> <li> <p><code>--highsymmetrypoint value</code>     default value none     Samy as above, but you can specify the label of a high-symmetry point instead, e.g. \"X\" or \"L\".</p> </li> <li> <p><code>--max_energy value</code>     default value 1.4     Maximum energy where the output is cut off, in multiples of the maximum harmonic frequency.</p> </li> <li> <p><code>--no_isotope_scattering</code>     default value .false.     Switch off isotope (mass disorder) scattering</p> </li> <li> <p><code>--no_thirdorder_scattering</code>     default value .false.     Switch of three-phonon scattering</p> </li> <li> <p><code>--geninterp</code>     default value .false.     First rule of interpolation is you do not talk about interpolation.</p> </li> <li> <p><code>--fancyinterp</code>     default value .false.     Second rule of interpolation is you do not talk about interpolation.</p> </li> <li> <p><code>--grid</code>     default value .false.     Calculate spectral functions on a grid.</p> </li> <li> <p><code>--readiso</code>     default value .false.     Read the isotope distribution from file</p> </li> <li> <p><code>--readqmesh</code>     default value .false.     Read the q-point mesh from file. To generate a q-mesh file, see the genkpoints utility.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/lineshape/#examples","title":"Examples","text":"<p><code>mpirun lineshape --highsymmetrypoint X --temperature 500</code> </p> <p><code>mpirun lineshape --path -qg 10 10 10 --noisotope</code> </p> <p><code>mpirun lineshape --dos -qg 10 10 10 --dos_qpoint_grid 24 24 24</code> </p>"},{"location":"program/lineshape/#long-summary","title":"Long summary","text":"<p>This code calculates the energy-dependent self energy from three-phonon scattering, as well as the contributions from mass imperfections and four-phonon scattering. It can produce nice figures like this:</p> <p></p>"},{"location":"program/lineshape/#background","title":"Background","text":"<p>It is nowadays routine to calculate e.g. lattice thermal conductivity using perturbation theory. At that level of approximation, you calculate the phonon lifetime via the imaginary part of the phonon self-energy at the harmonic frequencies. In general, however, the picture with a well defined phonon, shifted by a small energy \\(\\Delta\\) and broadened by \\(\\Gamma\\) is not enough. In general, the phonon self-energy is energy-dependent,1,2</p> \\[ \\begin{equation} \\Sigma(\\Omega) = \\Delta(\\Omega) + i\\Gamma(\\Omega) \\,, \\end{equation} \\] <p>where we use \\(\\Omega\\) to distinguish this energy from the eigenvalues of the dynamical matrix, \\(\\omega^2\\). Inelastic neutron measurements sometimes show scattering cross sections that deviate strongly from a Lorentzian. To reproduce this computationally, start by noting that in an idealised experiment the one-phonon neutron cross section would be measured as1,2</p> \\[ \\begin{equation} \\sigma_{\\lambda}(\\Omega) \\propto \\frac{   2 \\omega_{\\lambda}\\Gamma_{\\lambda}(\\Omega) }{   \\left[\\Omega^2-\\omega^2_{\\lambda}-2\\omega_{\\lambda}   \\Delta_{\\lambda}(\\Omega)\\right]^2+4\\omega^2_{\\lambda}\\Gamma_{\\lambda}^2(\\Omega)}\\,. \\end{equation} \\] <p>Here \\(\\omega^2_{\\lambda}\\) are the eigenvalues of the dynamical matrix, \\(\\Delta_{\\lambda}(\\Omega)\\) and \\(\\Gamma_{\\lambda}(\\Omega)\\) are the real and imaginary parts of the frequency dependent self-energy, and \\(\\hbar\\Omega\\) is a probing energy. This is the quantity referred to as the lineshape. If you let \\(\\Delta\\) and \\(\\Gamma\\) go to a small constant, this reduces to a Lorentzian as expected.</p> <p>The energy axis is the probing energy, and the intensity represents the likelihood of exciting a phonon with energy \\(\\hbar\\Omega\\) and momentum \\(\\textbf{q}\\). We can interpret the cross section, or phonon lineshape, as the broadened and shifted phonon frequencies. The term \"broadening\" is used in the sense of a spectral representation: non-interaction quasiparticles are represented as Dirac \\(\\delta\\)-functions, but in the interacting case these are replaced by distributions with finite widths.</p> <p>Given the third order force constants, the imaginary part of the phonon self-energy can be calculated:1,2,4</p> \\[ \\begin{equation} \\begin{split} \\Gamma_{\\lambda}(\\Omega) &amp; =  \\frac{\\hbar\\pi}{16} %\\frac{V}{(2\\pi)^3} \\sum_{\\lambda'\\lambda''} \\left| \\Phi_{\\lambda\\lambda'\\lambda''} \\right|^2 \\big{\\{}(n_{\\lambda'}+n_{\\lambda''}+1) \\delta(\\Omega-\\omega_{\\lambda'}-\\omega_{\\lambda''})+ \\\\&amp; +(n_{\\lambda'}-n_{\\lambda''}) \\left[ \\delta(\\Omega-\\omega_{\\lambda'}+\\omega_{\\lambda''}) - \\delta(\\Omega+\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\right] \\big{\\}} \\end{split} \\end{equation} \\] <p>The imaginary part of the self energy is a sum over all possible three-phonon interactions $ \\lambda \\lambda' \\lambda''$, \\(n_{\\lambda}\\) are the Bose-Einstein thermal occupation factors counting the number of phonons in each mode. The expression for the self-energy is then an integral over the allowed processes (conserving energy and momentum), weighted by how many phonons are in each of the different modes, with the scattering strength determined by the three-phonon matrix element:</p> \\[ \\begin{equation} \\Phi_{\\lambda\\lambda'\\lambda''} = \\sum_{ijk} \\sum_{\\alpha\\beta\\gamma} \\frac{ \\epsilon_{\\lambda}^{i \\alpha} \\epsilon_{\\lambda'}^{j \\beta} \\epsilon_{\\lambda''}^{k \\gamma} }{ \\sqrt{m_{i}m_{j}m_{j}} \\sqrt{     \\omega_{\\lambda}     \\omega_{\\lambda'}     \\omega_{\\lambda''}} } \\Phi^{\\alpha\\beta\\gamma}_{ijk} e^{i \\mathbf{q}\\cdot\\mathbf{r}_i + i \\mathbf{q}'\\cdot\\mathbf{r}_j+i \\mathbf{q}''\\cdot\\mathbf{r}_k} \\end{equation} \\] <p>The real part is conveniently calculated via a Kramers-Kronig transform (it can of course be expressed in a similar way as the imaginary part:1,2,4</p> \\[ \\begin{equation} \\Delta(\\Omega)=\\frac{1}{\\pi}\\int\\frac{\\Gamma(\\omega)}{\\omega-\\Omega}\\mathrm{d}\\omega\\,. \\end{equation} \\] <p>A significant deviation from Lorentzian lineshapes indicates anharmonic effects and can be checked by considering phonon spectral representation \\(\\sigma_{\\lambda}\\).</p>"},{"location":"program/lineshape/#mass-disorder","title":"Mass disorder","text":"<p>The mass disorder term is also included, stemming from the natural distribution of isotopes. According to Tamura5, if the isotopes are randomly distributed on the lattice sites then the strength of the isotope effects can be given by a mass variance parameter \\(g\\):</p> \\[ \\begin{equation} g_i=\\sum_j c_{i}^j \\left(\\frac{m_i^j-\\bar{m_i}}{\\bar{m_i}}\\right)^2 \\end{equation} \\] <p>where \\(\\bar{m_i}\\) is the average isotopic mass( \\(\\bar{m_i}=\\sum_j c_i^j m_i^j\\) ), \\(m^j_i\\) is the mass of isotope \\(j\\) of atom \\(i\\) and \\(c^j_i\\) is its concentration. We can write an expression for the imaginary part of the isotope self-energy:</p> \\[ \\begin{equation} \\Gamma_{\\lambda}(\\Omega)= \\frac{\\pi}{4} \\sum_{\\lambda'} \\Lambda_{\\lambda\\lambda'} \\delta(\\Omega-\\omega_{\\lambda}') \\end{equation} \\] <p>where</p> \\[ \\begin{equation} \\Lambda_{\\lambda\\lambda'}= \\omega_{\\lambda}\\omega_{\\lambda'} \\sum_i g_i \\left| \\epsilon_{\\lambda}^{i \\dagger} \\epsilon_{\\lambda'}^{i} \\right|^2 \\end{equation} \\] <p>Per default, the isotope distribution will be the natural distribution. In case some other distribution is desired, this can be specified.</p>"},{"location":"program/lineshape/#input-files","title":"Input files","text":"<p>Required files:</p> <ul> <li>infile.ucposcar</li> <li>infile.forceconstant</li> <li>infile.forceconstant_thirdorder</li> </ul> <p>Optional files:</p> <ul> <li>infile.qpoints_dispersion (to specify the q-point path)</li> <li>infile.isotopes (for non-natural isotope distribution)</li> </ul>"},{"location":"program/lineshape/#output-files","title":"Output files","text":"<p>There are three possible modes for this code: the lineshape at a single q-point (default), along a path in the BZ (<code>--path</code>) or over the full BZ as a phonon DOS (<code>--dos</code>). The output files will differ. For lineshape at a single q, you get</p>"},{"location":"program/lineshape/#outfilelineshapehdf5","title":"<code>outfile.lineshape.hdf5</code>","text":"<p>@todo Double-check that code snippets work.</p> <p>This file is self-documented. You can produce plots like this:</p> <p></p> <p>For this plot, I used the following matlab snippet:</p> <pre><code>% read everything from file\nfn=('outfile.phonon_lineshape.hdf5');\n% lineshape things\nx1=h5read(fn,'/intensity_axis');\ny1=h5read(fn,'/intensity');\n% self-energies\nx2=h5read(fn,'/selfenergy_axis');\nz1=h5read(fn,'/imaginary_threephonon_selfenergy');\nz2=h5read(fn,'/imaginary_isotope_selfenergy');\nz3=h5read(fn,'/real_threephonon_selfenergy');\n% and the unit and bare harmonic frequencies\nenergyunit=h5readatt(fn,'/selfenergy_axis','unit');\nomega=h5read(fn,'/harmonic_frequencies');\n% create a legend\nfor i=1:length(omega)\nlgd{i}=['mode ' num2str(i) ', \\omega = ' num2str(omega(i),'%10.5f') energyunit];\nend\nfigure(1); clf; hold on;\nsubplot(2,1,1); hold on; box on;\nplot(x1,y1)\ntitle('Lineshape')\nxlabel(['\\omega (' energyunit ')'])\nylabel(['states/' energyunit ])\nset(gca,'xminortick','on','yminortick','on','xlim',[0 max(omega)*1.4])\nlegend(lgd,'edgecolor','none')\nsubplot(2,2,3); hold on; box on;\nplot(x2,z1+z2)\ntitle('Imaginary self-energy')\nxlabel(['\\omega (' energyunit ')'])\nylabel(['\\Gamma (' energyunit ')'])\nset(gca,'xminortick','on','yminortick','on','xlim',[0 max(omega)*1.4])\nsubplot(2,2,4); hold on; box on;\nplot(x2,z3)\ntitle('Real self-energy')\nxlabel(['\\omega (' energyunit ')'])\nylabel(['\\Delta (' energyunit ')'])\nset(gca,'xminortick','on','yminortick','on','xlim',[0 max(omega)*1.4])\n</code></pre>"},{"location":"program/lineshape/#outfilephonon_spectral_functionhdf5","title":"<code>outfile.phonon_spectral_function.hdf5</code>","text":"<p>These files represent the properties calculated as a function of \\(\\textbf{q}\\) along high symmetry directions in the Brillouin zone, such as the plot at the top of this page. The file is self-documented. Below is a sample matlab snippet that plots the spectral function:</p> <pre><code>% read everything from file\nfn=('outfile.phonon_spectral_function.hdf5');\nh5disp(fn)\nx=h5read(fn,'/q_values');\ny=h5read(fn,'/energy_values');\ngz=h5read(fn,'/spectral_function');\nxtck=h5read(fn,'/q_ticks');\nxtcklabel=strsplit(h5readatt(fn,'/','q_tick_labels'));\nenergyunit=h5readatt(fn,'/','energy_unit');\n% plot the results\nfigure(1); clf; hold on; box on;\n[gy,gx]=meshgrid(y,x);\n% change the shift here until it looks nice\ns=pcolor(gx,gy,log10(gz+1E-1));\nset(s,'edgecolor','none','facecolor','interp')\nset(gca,'xtick',xtck,'xticklabel',xtcklabel)\nylabel(['Energy (' energyunit ')'])\nxlim([0 max(x)])\nylim([0 max(y)])\n</code></pre> <p>With matplotlib here is a sample snippet that produces decent-looking plots</p> <pre><code>#!/usr/local/opt/python/libexec/bin/python\nimport matplotlib.pyplot as plt # to be able to plot\nimport numpy as np              # to math a little\nimport h5py as h5               # to read the file\n# open the sqe file\nf = h5.File('outfile.phonon_spectral_function.hdf5','r')\n# get axes and intensity\nx = np.array(f.get('q_values'))\ny = np.array(f.get('energy_values'))\ngz = np.array(f.get('spectral_function'))\n# for plotting, turn the axes into 2d arrays\ngy, gx = np.meshgrid(y,x)\n# x-ticks\nxt = np.array(f.get('q_ticks'))\n# labels for the x-ticks\nxl = f.attrs.get('q_tick_labels').decode('ascii').split()\n# get a proper Greek \u0393\nxl = [w.replace('G','\u0393') for w in xl]\n# label for y-axis\nunit = f['energy_values'].attrs.get('unit').decode('ascii')\n# set a sensible size for the plot. This is a prb sized figure.\nfigure_height=2.5\nfigure_width=3.4039\nfig=plt.figure(figsize=(figure_width,figure_height),dpi=300)   # Size of figure in prb\nplt.rcParams.update({'font.size': 8})\nplt.rcParams.update({'pdf.fonttype': 42})\nplt.tick_params(axis='y', which='major', labelsize=6)\n# actual plot, logarithmic color scale\n# make sure the intensities are 0-1\ngz=gz-gz.min()\ngz=gz/gz.max()\n# add a little bit so the logscale does not get angry at 0 intensity\n# change this magic number until it looks nice.\ngz=gz+1E-4\n# make it logscale\ngz=np.log(gz)\nplt.pcolormesh(gx, gy, gz, cmap='viridis', rasterized=True, snap=True)\n# Now start making the plot a little prettier:\nax=plt.gca()\nax.axis([x.min(), x.max(), y.min(), y.max()])\n# Set proper labels on the q-axis\nax.set_xticks(xt)\nax.set_xticklabels(xl)\n# Set the size of the ticks, turn on minor ticks for the y-label only\nax.minorticks_on()\nax.tick_params(axis='both',which='major',pad=1.5,width=0.5,length=2,direction='in',bottom=True,top=True,left=True,right=True)\nax.tick_params(axis='both',which='minor',pad=1,width=0.5,length=1,direction='in',bottom=False,top=False,left=True,right=True)\nax.set_ylabel(\"Energy (\"+unit+\")\",labelpad=2)\n# Set linewidth for the axes too\nfor axis in ['top','bottom','left','right']:\nax.spines[axis].set_linewidth(0.5)\n# No need to have lots of whitespace around the plot, adjust it a little\n# So I know the height of my plot, how large is a label? And what are the unit? Hard to know.\n# But if I know that, I can figure out reasonable spacings, I suppose. I know a\n# typographers point is 1/72 of an inch. M is the widest character.\nheight_of_label=0.15 # in inches, maybe? Should query this from the font/label text\nwidth_of_label=0.05  # in inches, maybe? Should also query this\n# These should be updated to take all the spacings into account\npad_bottom=1-(figure_height-height_of_label)/figure_height\npad_top=(figure_height-0.5*width_of_label)/figure_height\npad_left=1-(figure_width-width_of_label-height_of_label*1.3)/figure_width\npad_right=(figure_width-width_of_label)/figure_width\n# Anyway, adjust the whitespace so that it's a tight figure\nplt.subplots_adjust(left=pad_left, right=pad_right, top=pad_top, bottom=pad_bottom)\n# Uncomment the next line to save it as a pdf instead.\n#fig.savefig(\"foo.pdf\", bbox_inches='tight', transparent=True, dpi=600)\nplt.show()\n</code></pre>"},{"location":"program/lineshape/#outfilephonon_dos_lineshapehdf5","title":"<code>outfile.phonon_dos_lineshape.hdf5</code>","text":"<p>Is identical to this.</p> <ol> <li> <p>Maradudin, A. A., &amp; Fein, A. (1962). Scattering of Neutrons by an Anharmonic Crystal. Physical Review, 128(6), 2589\u20132608. \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Cowley, R. A. (1968). Anharmonic crystals. Reports on Progress in Physics, 31(1), 123\u2013166. \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Leibfried, G., &amp; Ludwig, W. (1961). Theory of Anharmonic Effects in Crystals. Solid State Physics - Advances in Research and Applications, 12(C), 275\u2013444. \u21a9</p> </li> <li> <p>Wallace, D. C. (1998). Thermodynamics of crystals. Dover Publications, Incorporated. \u21a9\u21a9</p> </li> <li> <p>Tamura, S. (1983). Isotope scattering of dispersive phonons in Ge. Physical Review B, 27(2), 858\u2013866. \u21a9</p> </li> </ol>"},{"location":"program/pack_simulation/","title":"Pack simulation","text":""},{"location":"program/pack_simulation/#short-description","title":"Short description","text":"<p>Small utility to pack a simulation to hdf5.</p>"},{"location":"program/pack_simulation/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--stride value</code>, <code>-s value</code>     default value 1     Pack every N configuration instead of all.</p> </li> <li> <p><code>--nrand value</code>     default value -1     Pack N random configurations instead of all.</p> </li> <li> <p><code>--temperature value</code>     default value -1     Override the simulation temperature.</p> </li> <li> <p><code>--variable_cell</code>, <code>-npt</code>     default value .false.     Make sure to store variable cell information.</p> </li> <li> <p><code>--magnetic_moments</code>, <code>-mag</code>     default value .false.     Make sure to store projected magnetic moments.</p> </li> <li> <p><code>--dielectric</code>     default value .false.     Make sure to store dielectric constant and Born charges.</p> </li> <li> <p><code>--molecular_dynamics</code>, <code>-md</code>     default value .false.     Make sure to specify that this is real molecular dynamics.</p> </li> <li> <p><code>--notidy</code>     default value .false.     Per default the simulation is cleaned, drift removed and so on. This switch skips that.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/pack_simulation/#examples","title":"Examples","text":"<p><code>pack_simulation</code> </p>"},{"location":"program/pack_simulation/#long-summary","title":"Long summary","text":"<p>This utility takes the plain-text input files and packs them to hdf5. The options allow you to pack a subset and specify what information to include. The resulting output file can take the place of the regular input files. This is by no means a necessary tool, the main utility is reduced file size and increased io speed.</p>"},{"location":"program/pack_simulation/#input-files","title":"Input files","text":"<ul> <li>infile.ucposcar</li> <li>infile.ssposcar</li> <li>infile.positions</li> <li>infile.forces</li> <li>infile.stat</li> <li>infile.meta</li> </ul>"},{"location":"program/pack_simulation/#output-files","title":"Output files","text":""},{"location":"program/pack_simulation/#outfilesimhdf5","title":"<code>outfile.sim.hdf5</code>","text":"<p>This is merely an archive that contains all the information in the input files but packed to a single file. For the casual use it has little benefit except using considerably less space.</p>"},{"location":"program/phonon_dispersion_relations/","title":"Phonon dispersion relations","text":""},{"location":"program/phonon_dispersion_relations/#short-description","title":"Short description","text":"<p>Calculate phonon dispersions and related quantities. Per default, only the dispersions along a default path will be calculated. Options are available for calculating mode gruneisen parameters, phonon density of states projected in a variety of ways, thermodynamic quantities and pure data dumps.</p>"},{"location":"program/phonon_dispersion_relations/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--unit value</code>, value in: <code>thz,mev,icm</code>     default value thz     Choose the output unit. The options are terahertz (in frequency, not angular frequency), inverse cm or meV.</p> </li> <li> <p><code>--nq_on_path value</code>, <code>-nq value</code>     default value 100     Number of q-points between each high symmetry point</p> </li> <li> <p><code>--readpath</code>, <code>-rp</code>     default value .false.     Read the q-point path from <code>infile.qpoints_dispersion</code>. Use crystal structure into to generate an example.</p> </li> <li> <p><code>--dos</code>     default value .false.     Calculate the phonon DOS</p> </li> <li> <p><code>--qpoint_grid value#1 value#2 value#3</code>, <code>-qg value#1 value#2 value#3</code>     default value 26 26 26     Density of q-point mesh for Brillouin zone integrations.</p> </li> <li> <p><code>--meshtype value</code>, value in: <code>1,2,3,4</code>     default value 1     Type of q-point mesh. 1 Is a Monkhorst-Pack mesh, 2 an FFT mesh and 3 my fancy wedge-based mesh with approximately the same density the grid-based meshes. 4 build the commensurate mesh of an approximately cubic supercell.</p> </li> <li> <p><code>--sigma value</code>     default value 1.0     Global scaling factor for Gaussian/adaptive Gaussian smearing. The default is determined procedurally, and scaled by this number.</p> </li> <li> <p><code>--readqmesh</code>     default value .false.     Read the q-point mesh from file. To generate a q-mesh file, see the genkpoints utility.</p> </li> <li> <p><code>--integrationtype value</code>, <code>-it value</code>, value in: <code>1,2,3</code>     default value 2     Type of integration for the phonon DOS. 1 is Gaussian, 2 adaptive Gaussian and 3 Tetrahedron.</p> </li> <li> <p><code>--dospoints value</code>     default value 400     Number of points on the frequency axis of the phonon dos.</p> </li> <li> <p><code>--temperature value</code>     default value -1     Evaluate thermodynamic phonon properties at a single temperature.</p> </li> <li> <p><code>--temperature_range value#1 value#2 value#3</code>     default value -1 -1 -1     Evaluate thermodynamic phonon properties for a series of temperatures, specify min, max and the number of points.</p> </li> <li> <p><code>--gruneisen</code>     default value .false.     Use third order force constants to calculate mode Gruneisen parameters.</p> </li> <li> <p><code>--dumpgrid</code>     default value .false.     Write files with q-vectors, frequencies, eigenvectors and group velocities for a grid.</p> </li> <li> <p><code>--pdf</code>, <code>-p</code>     default value .false.     Produce gnuplot_pdf output file for printing to pdf.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/phonon_dispersion_relations/#examples","title":"Examples","text":"<p><code>phonon_dispersion_relations</code> </p> <p><code>phonon_dispersion_relations --dos --qpoint_grid 24 24 24</code> </p>"},{"location":"program/phonon_dispersion_relations/#what-does-this-code-produce","title":"What does this code produce?","text":"<p>This code calculates phonon dispersion relations, usually presented like this:</p> <p></p> <p>Where the color of the line indicates the projection onto species. The same data can also be presented as a density of states, like this:</p> <p></p> <p>By default, minimal input is needed, but many options to tailor the output exist.</p>"},{"location":"program/phonon_dispersion_relations/#equations-of-motion-in-a-harmonic-crystal","title":"Equations of motion in a harmonic crystal","text":"<p>As detailed in extract forceconstants we have mapped the Born-Oppenheimer to an effective potential. A model Hamiltonian truncated at the second order (a harmonic Hamiltonian) is given by1</p> \\[ \\begin{equation} \\hat H=\\sum_{\\kappa} \\frac{\\mathbf{p}_{\\kappa}^2}{2m_{\\kappa}} + \\frac{1}{2} \\sum_{\\kappa\\lambda}\\sum_{\\alpha\\beta}  \\Phi_{\\kappa\\lambda}^{\\alpha\\beta} u^{\\alpha}_{\\kappa} u^{\\beta}_{\\lambda}\\, \\end{equation} \\] <p>Where \\(\\kappa,\\lambda\\) are indices to atoms, \\(\\alpha,\\beta\\) Cartesian indices and \\(\\mathbf{u}\\) a displacement from equilibrium positions. To clarify, the instantaneous position of an atom is given by</p> \\[ \\begin{equation} \\mathbf{r}_{\\kappa} = \\mathbf{R}_{\\mu} + \\boldsymbol{\\tau}_{i} + \\mathbf{u} \\end{equation} \\] <p>such that \\(\\mathbf{R} +\\boldsymbol{\\tau}\\) denote the equilibrium position of the atom. The lattice vector \\(\\mathbf{R}\\) locate the unit cell, \\(\\boldsymbol{\\tau}\\) locate the atom in the unit cell, and \\(\\mathbf{u}\\) how far the atom has moved from the reference positions. Ignoring surface effects, we can write the equations of motion:</p> \\[ \\begin{equation} \\ddot{\\mathbf{u}}_{\\mu i} m_{\\mu i} = -\\sum_{\\nu j} \\mathbf{\\Phi}_{\\mu i,\\nu j}\\mathbf{u}_{\\nu j} \\,. \\end{equation} \\] <p>Here we expanded the atom index \\(\\kappa\\) to the double index indicating cell \\(\\mu\\) and position \\(i\\). Since we deal with infinite crystals with periodic boundary conditions, the equations of motion will not depend on cell index \\(\\mu\\), and that index can be dropped.</p> \\[ \\begin{equation}\\label{eq:eqmotion1} \\ddot{\\mathbf{u}}_{i} m_{i} = -\\sum_{\\nu j} \\mathbf{\\Phi}_{\\mu i,\\nu j}\\mathbf{u}_{\\nu j}. \\end{equation} \\] <p>I prefer a truncated notation:</p> \\[ \\begin{equation} \\ddot{\\mathbf{u}}_{i} m_{i} = -\\sum_{\\mathbf{R}} \\mathbf{\\Phi}_{ij}\\left( \\mathbf{R} \\right)\\mathbf{u}_{j}. \\end{equation} \\] <p>Where \\(\\mathbf{R}\\) implies the cell index corresponding to atom \\(j\\). To solve these equations of motion, we can use a plane-wave ansatz:</p> \\[ \\begin{equation} \\mathbf{u}_{i}=\\frac{1}{\\sqrt{m_i}} \\sum_{\\mathbf{q}} A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}^{i} e^{ i \\left(\\mathbf{q} \\cdot \\mathbf{R} - \\omega t \\right) }. \\end{equation} \\] <p>Here the displacements are expressed as a sum of plane waves, or normal modes, each with wave vector \\(\\mathbf{q}\\) and frequency \\(\\omega\\). \\(\\boldsymbol{\\epsilon}\\) is a polarisation vector, and \\(A_{\\mathbf{q}}\\) the normal mode amplitude. Substituting this into \\(\\eqref{eq:eqmotion1}\\) and exploiting the orthogonality of planes waves gives,</p> \\[ \\begin{split} \\sqrt{m_i}\\sum_{\\mathbf{q}} \\omega^2 A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}^{i} e^{ i \\left(\\mathbf{q} \\cdot \\mathbf{R}_i - \\omega t \\right) } = &amp; \\sum_{\\mathbf{R}}\\sum_{\\mathbf{q}} \\frac{A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}^{i}}{\\sqrt{m_j}} \\mathbf{\\Phi}_{ij}\\left( \\mathbf{R}_j \\right) e^{ i \\left(\\mathbf{q} \\cdot \\mathbf{R}_j - \\omega t \\right) } \\\\ % % \\sum_{\\mathbf{q}} \\omega^2 A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}^{i} e^{ i \\mathbf{q} \\cdot \\mathbf{R}_i } = &amp; \\sum_{\\mathbf{R}}\\sum_{\\mathbf{q}} \\frac{A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}^{i}}{\\sqrt{m_i m_j}} \\mathbf{\\Phi}_{ij}\\left( \\mathbf{R}_j \\right) e^{ i \\mathbf{q} \\cdot \\mathbf{R}_j } \\\\ % % \\sum_{\\mathbf{q}'} \\omega^2 A_{\\mathbf{q}'} \\boldsymbol{\\epsilon}_{\\mathbf{q}'}^{i} e^{ i \\mathbf{q}' \\cdot \\mathbf{R}_i } e^{ -i \\mathbf{q} \\cdot \\mathbf{R}_i } = &amp; \\sum_{\\mathbf{R}}\\sum_{\\mathbf{q}'} \\frac{A_{\\mathbf{q}'} \\boldsymbol{\\epsilon}_{\\mathbf{q}'}^{i}}{\\sqrt{m_i m_j}} \\mathbf{\\Phi}_{ij}\\left( \\mathbf{R}_j \\right) e^{ i \\mathbf{q}' \\cdot \\mathbf{R}_j } e^{ -i \\mathbf{q} \\cdot \\mathbf{R}_i } \\\\ % % \\omega^2 A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}^{i} = &amp; A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}^{i} \\sum_{\\mathbf{R}} \\frac{\\mathbf{\\Phi}_{ij}\\left( \\mathbf{R}_j \\right)}{\\sqrt{m_i m_j}} e^{ i \\mathbf{q} \\cdot \\mathbf{R}_j } \\\\ % % \\omega^2_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}= &amp; \\mathbf{\\Phi}(\\mathbf{q}) \\boldsymbol{\\epsilon}_{\\mathbf{q}}\\,, \\end{split} \\] <p>where the periodic boundary conditions limit the choices of \\(\\mathbf{q}\\) to a wave vector \\(\\mathbf{q}\\) in the first Brillouin zone. The dynamical matrix \\(\\mathbf{\\Phi}(\\mathbf{q})\\) is given by</p> \\[ \\begin{equation} \\mathbf{\\Phi}(\\mathbf{q})= \\begin{pmatrix} \\mathbf{\\Phi}_{11}(\\mathbf{q}) &amp; \\cdots &amp; \\mathbf{\\Phi}_{N 1}(\\mathbf{q}) \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ \\mathbf{\\Phi}_{1N}(\\mathbf{q}) &amp; \\cdots &amp; \\mathbf{\\Phi}_{N N}(\\mathbf{q}) \\\\ \\end{pmatrix} \\end{equation} \\] <p>This is the Fourier transform of the mass-weighted force constant matrix, where each \\(3 \\times 3\\) submatrix of the full \\(3N \\times 3N\\) is given by</p> \\[ \\begin{equation} \\mathbf{\\Phi}_{ij}(\\mathbf{q})= \\sum_{\\mathbf{R}} \\frac{ \\mathbf{\\Phi}_{ij}(\\mathbf{R}) }{\\sqrt{m_i m_j}} e^{i\\mathbf{q}\\cdot \\mathbf{R}} \\,. \\end{equation} \\] <p>The eigenvalues \\(\\omega^2_{\\mathbf{q}s}\\) and eigenvectors \\(\\boldsymbol{\\epsilon}_{\\mathbf{q}s}\\) of the dynamical matrix denote the possible normal mode frequencies and polarizations of the system. The eigenvalues have the same periodicity as the reciprocal lattice; hence it is convenient to limit the solution to all vectors \\(\\mathbf{q}\\) in the first Brillouin zone. It is also worth defining the partial derivatives of the dynamical matrix:</p> \\[ \\begin{align} \\frac{\\partial \\mathbf{\\Phi}_{ij}(\\mathbf{q})}{\\partial q_\\alpha}  &amp; = \\sum_{\\mathbf{R}} iR_\\alpha \\frac{ \\mathbf{\\Phi}_{ij}(\\mathbf{R}) }{\\sqrt{m_i m_j}} e^{i\\mathbf{q}\\cdot \\mathbf{R}}. \\\\ \\frac{\\partial^2 \\mathbf{\\Phi}_{ij}(\\mathbf{q})}{\\partial q_\\alpha \\partial q_{\\beta}}  &amp; = -\\sum_{\\mathbf{R}} R_{\\alpha} R_{\\beta} \\frac{ \\mathbf{\\Phi}_{ij}(\\mathbf{R}) }{\\sqrt{m_i m_j}} e^{i\\mathbf{q}\\cdot \\mathbf{R}}. \\end{align} \\] <p>By calculating the eigenvalues and eigenvectors of the dynamical matrix over the Brillouin zone, all thermodynamic quantities involving the atomic motions can be determined, as far as the harmonic approximation is valid. If you are curious where the amplitudes of the normal modes disappeared, see canonical configuration.</p>"},{"location":"program/phonon_dispersion_relations/#long-ranged-interactions-in-polar-materials","title":"Long-ranged interactions in polar materials","text":"<p>When determining the dynamical matrix, the sum over lattice vectors \\(\\mathbf{R}\\) should in principle be carried out over all pairs. In practice, we assume that the interactions are zero beyond some cutoff (see extract forceconstants option <code>-rc2</code>), and truncate the sum. This is not a valid approach when dealing with polar material where the induced dipole-dipole interactions are essentially infinite-ranged. See for example Gonze &amp; Lee.5 6 When dealing with these long-ranged electrostatics we start by defining the Born effective charge tensor:</p> \\[ Z_{i}^{\\alpha\\beta} = \\frac{\\partial^2 U}{\\partial \\varepsilon^{\\alpha} \\partial u_{i}^{\\beta}} \\] <p>That is the mixed derivative of the energy with respect to electric field \\(\\varepsilon\\) and displacement \\(\\mathbf{u}\\). Displacing an atom from its equilibrium position induces a dipole, given by</p> \\[ \\mathbf{d}_{i} = \\mathbf{Z}_{i}\\mathbf{u}_{i} \\] <p>The pairwise dipole-dipole interactions can be expressed as forceconstants:</p> \\[ \\begin{align} \\Phi^{\\textrm{dd}}|^{\\alpha\\beta}_{ij} &amp; = \\sum_{\\gamma\\delta} Z_{i}^{\\alpha\\gamma}Z_{j}^{\\beta\\delta} \\widetilde{\\Phi}^{\\gamma\\delta}_{ij} \\\\ \\widetilde{\\Phi}^{\\alpha\\beta}_{ij} &amp; = \\frac{1}{4\\pi\\epsilon_0} \\frac{1}{\\sqrt{\\det \\epsilon}} \\left(     \\frac     { \\widetilde{\\epsilon}^{\\alpha\\beta} }     {|\\Delta_{ij}|_{\\epsilon}^{3}}     -3 \\frac     {\\Delta_{ij}^{\\alpha}\\Delta_{ij}^{\\beta}}     {|\\Delta_{ij}|_{\\epsilon}^{5}} \\right) \\end{align} \\] <p>Here \\(\\boldsymbol{\\epsilon}\\) is the dielectric tensor, \\(\\widetilde{\\boldsymbol{\\epsilon}}=\\boldsymbol{\\epsilon}^{-1}\\) its inverse and \\(\\Delta\\) realspace distances using the dielectric tensor as a metric:</p> \\[ \\begin{align} \\mathbf{r}_{ij} &amp; = \\mathbf{R}_{j}+\\mathbf{\\tau}_j-\\mathbf{\\tau}_i \\\\ \\mathbf{\\Delta}_{ij} &amp; =\\widetilde{\\boldsymbol{\\epsilon}}\\mathbf{r}_{ij} \\\\ |\\Delta_{ij}|_{\\epsilon} &amp; = \\sqrt{\\mathbf{\\Delta}_{ij} \\cdot \\mathbf{r}_{ij}} \\end{align} \\] <p>This poses an issue when calculating the dynamical matrix: the interactions die off as \\(~1/r^{3}\\) which makes it necessary to extend the sum over lattice vectors to infinity. This is remedied with the usual Ewald technique:</p> \\[ \\widetilde{\\mathbf{\\Phi}}_{ij} (\\mathbf{q})= \\widetilde{\\mathbf{\\Phi}}^\\textrm{r}+\\widetilde{\\mathbf{\\Phi}}^\\textrm{q}+\\widetilde{\\mathbf{\\Phi}}^\\textrm{c} \\] <p>Dividing the sum into a realspace part, a reciprocal part and a connecting part. The realspace part is given by</p> \\[ \\begin{align} \\widetilde{\\mathbf{\\Phi}}^\\textrm{r}_{ij} &amp; = -\\frac{\\Lambda^3}{4\\pi\\epsilon_0\\sqrt{\\det \\epsilon}} \\sum_{\\mathbf{R}} \\mathbf{H}(\\Lambda \\Delta_{ij},\\Lambda|\\Delta_{ij}|_{\\epsilon}) e^{i \\mathbf{q} \\cdot \\mathbf{R}} \\\\ %% \\frac{\\partial \\widetilde{\\mathbf{\\Phi}}^\\textrm{r}_{ij}}{\\partial q_\\alpha}  &amp; = -\\frac{\\Lambda^3}{4\\pi\\epsilon_0\\sqrt{\\det \\epsilon}} \\sum_{\\mathbf{R}} iR_\\alpha \\mathbf{H}(\\Lambda \\Delta_{ij},\\Lambda|\\Delta_{ij}|_{\\epsilon}) e^{i \\mathbf{q} \\cdot \\mathbf{R}} \\end{align} \\] <p>where</p> \\[ H_{\\alpha\\beta}(\\mathbf{x},y) = \\frac{x_{\\alpha}x_{\\beta} }{y^2} \\left[ \\frac{3\\,\\textrm{erfc}\\,y}{y^3} + \\frac{2 e^{-y^2}}{\\sqrt{\\pi}}\\left(\\frac{3}{y^2}+2 \\right) \\right] -\\widetilde{\\epsilon}_{\\alpha\\beta} \\left[ \\frac{\\textrm{erfc}\\,y}{y^3} + \\frac{2 e^{-y}}{\\sqrt{\\pi} y^2 } \\right]\\,. \\] <p>In reciprocal space we have</p> \\[ \\begin{align} % % Not derivative %     \\widetilde{\\Phi}_\\textrm{q}|_{ij}     &amp;=     \\sum_{\\mathbf{K}=\\mathbf{G}+\\mathbf{q}}     \\chi_{ij}(\\mathbf{K},\\Lambda)     \\left( \\mathbf{K}\\otimes\\mathbf{K} \\right) \\\\ % % X-direction %     \\frac{\\partial}{\\partial q_x} \\widetilde{\\Phi}_\\textrm{q}|_{ij}     %     &amp;=     \\sum_{\\mathbf{K}=\\mathbf{G}+\\mathbf{q}}     \\chi_{ij}(\\mathbf{K},\\Lambda)     \\left( \\mathbf{K}\\otimes\\mathbf{K} \\right)     %     \\left(     i\\tau^x_{ij} - \\left[\\sum_{\\alpha} K_\\alpha \\epsilon_{\\alpha x}     \\right]     \\left[ \\frac{1}{\\|\\mathbf{K}\\|_{\\epsilon}}+\\frac{1}{4\\Lambda^2} \\right]     \\right) +     %     \\chi_{ij}(\\mathbf{K},\\Lambda)     \\begin{pmatrix}     2K_x &amp; K_y &amp; K_z \\\\     K_y &amp; 0 &amp; 0 \\\\     K_z &amp; 0 &amp; 0     \\end{pmatrix} \\\\ % % Y-direction %     \\frac{\\partial}{\\partial q_y} \\widetilde{\\Phi}_\\textrm{q}|_{ij}     %     &amp;=     \\sum_{\\mathbf{K}=\\mathbf{G}+\\mathbf{q}}     \\chi_{ij}(\\mathbf{K},\\Lambda)     \\left( \\mathbf{K}\\otimes\\mathbf{K} \\right)     %     \\left(     i\\tau^y_{ij} - \\left[\\sum_{\\alpha} K_\\alpha \\epsilon_{\\alpha y}     \\right]     \\left[ \\frac{1}{\\|\\mathbf{K}\\|_{\\epsilon}}+\\frac{1}{4\\Lambda^2} \\right]     \\right) +     %     \\chi_{ij}(\\mathbf{K},\\Lambda)     \\begin{pmatrix}     0 &amp; K_x &amp; 0 \\\\     K_y &amp; 2K_y &amp; K_z \\\\     0 &amp; K_z &amp; 0     \\end{pmatrix}\\\\ % % Z-direction %     \\frac{\\partial}{\\partial q_z} \\widetilde{\\Phi}_\\textrm{q}|_{ij}     %     &amp;=     \\sum_{\\mathbf{K}=\\mathbf{G}+\\mathbf{q}}     \\chi_{ij}(\\mathbf{K},\\Lambda)     \\left( \\mathbf{K}\\otimes\\mathbf{K} \\right)     %     \\left(     i\\tau^z_{ij} - \\left[\\sum_{\\alpha} K_\\alpha \\epsilon_{\\alpha z}     \\right]     \\left[ \\frac{1}{\\|\\mathbf{K}\\|_{\\epsilon}}+\\frac{1}{4\\Lambda^2} \\right]     \\right) +     %     \\chi_{ij}(\\mathbf{K},\\Lambda)     \\begin{pmatrix}     0 &amp; 0 &amp; K_x \\\\     0 &amp; 0 &amp; K_y \\\\     K_z &amp; K_y &amp; 2K_z     \\end{pmatrix} \\end{align} \\] <p>where</p> \\[ \\begin{align} \\chi_{ij}(\\mathbf{K},\\Lambda) &amp;  = \\frac{1}{\\Omega\\epsilon_0} \\frac{ \\exp\\left(i \\mathbf{q} \\cdot \\mathbf{\\tau}_{ij} \\right) \\exp\\left( -\\frac{\\|\\mathbf{K}\\|_{\\epsilon}}{4\\Lambda^2}  \\right) } {\\|\\mathbf{K}\\|_{\\epsilon}} \\\\ %% \\|\\mathbf{K}\\|_{\\epsilon} &amp; =\\sum_{\\alpha\\beta}\\epsilon_{\\alpha\\beta}K_\\alpha K_\\beta \\end{align} \\] <p>and finally a connecting part given by</p> \\[ \\widetilde{\\mathbf{\\Phi}}_\\textrm{c}|_{ij}= \\delta_{ij} \\frac{\\Lambda^3}{3 \\epsilon_0 \\pi^{3/2} \\sqrt{ \\det \\boldsymbol{\\epsilon} } } \\widetilde{\\boldsymbol{\\epsilon}} \\] <p>@todo Add the Hessian w.r.t q here. It is so long.</p> <p>This expression is invariant for any \\(\\Lambda&gt;0\\), which is chosen to make the real and reciprocal sums converge with as few terms as possible. Note that the Born charges are factored out from \\(\\widetilde{\\mathbf{\\Phi}}\\), and have to by multiplied in as described above. The derivatives with respect to \\(q\\) are reproduced because they are useful when calculating the gradient of the dynamical matrix, needed when determining group velocities. In the long-wavelength limit, \\(\\mathbf{q}\\rightarrow 0\\), the dipole-dipole dynamical matrix reduces to the familiar non-analytical term:</p> \\[ \\lim_{\\mathbf{q}\\rightarrow 0} \\mathbf{\\Phi}(\\mathbf{q}) = \\frac{1}{\\Omega\\epsilon_0} \\frac{ \\left(\\mathbf{Z}_i\\mathbf{q}\\right) \\otimes \\left(\\mathbf{Z}_j\\mathbf{q}\\right) }{\\mathbf{q}^T\\boldsymbol{\\epsilon}\\mathbf{q}} \\] <p>This package implements three different ways of dealing with these long-ranged interactions. For historical reasons, the so-called mixed-space approach is available, but it should not be used except as an example of what not to do.</p> <p>The technical issue is that the forces from a DFT calculation are not separated cleanly into \"electrostatic longrange\" and \"everything else\" components. The TDEP approach allows for two variants to separate this:</p>"},{"location":"program/phonon_dispersion_relations/#separation-approach-1","title":"Separation approach 1","text":"<p>This is the approach proposed by Gonze &amp; Lee6, only slightly adjusted since they assumed you start with reciprocal space dynamical matrices, whereas I start with realspace forceconstants. Algorithmically, it works like this:</p> <ul> <li>Define a \\(N_a \\times N_b \\times N_c\\) suprecell, large enough that it snugly fits your realspace forceconstants.</li> <li>Calculate the electrostatic dynamical matrices on a \\(N_a \\times N_b \\times N_c\\) \\(q\\)-mesh.</li> <li>Inverse fourier transform the electrostatic dynamical matrices to realspace forceconstants: $$ \\mathbf{\\Phi}^{\\textrm{dd}}{ij}(\\mathbf{R}) =\\frac{ \\sqrt{m_i m_j} }{N_a N_b N_c} \\sum{\\mathbf{q}}  \\Phi^{\\textrm{dd}}_{ij}(\\mathbf{q}) e^{-i\\mathbf{q} \\cdot \\mathbf{R}} $$</li> <li>Subtract these from the realspace forceconstants: $$ \\hat{\\mathbf{\\Phi}}{ij}(\\mathbf{R})= \\mathbf{\\Phi}{ij}(\\mathbf{R})- \\mathbf{\\Phi}^{\\textrm{dd}}_{ij}(\\mathbf{R}) $$</li> <li>Calculate the dynamical matrix as a sum of the short- and long-ranged contributions: $$ \\mathbf{\\Phi}{ij}(\\mathbf{q}) = \\hat{\\mathbf{\\Phi}}{ij}(\\mathbf{R}) + \\Phi^{\\textrm{dd}}_{ij}(\\mathbf{q}) $$</li> </ul> <p>At \\(\\mathbf{q}=0\\) the non-analytical contribution has to be added as well. This approach is reasonably robust, and works well in most materials. However, there are some aliasing contributions added since the realspace forceconstants are truncated by distance, and I propose a slight variation of this scheme:</p>"},{"location":"program/phonon_dispersion_relations/#separation-approach-2","title":"Separation approach 2","text":"<p>This idea is similar in spirit, but does the separation into long- and short-ranged interactions at an earlier stage.</p> <p>@todo Fill this in once published.</p>"},{"location":"program/phonon_dispersion_relations/#mixed-space-approach","title":"Mixed-space approach","text":"<p>This is implemented for historical reasons and for comparison, but disabled by default. It should not be used for anything, it is incorrect, and doing it right cost nothing.</p>"},{"location":"program/phonon_dispersion_relations/#other-dispersive-properties","title":"Other dispersive properties","text":"<p>We determine group velocities via the Hellman-Feynmann theorem:</p> \\[ \\begin{equation}     \\nabla_{\\mathbf{q}} \\omega^2_s = \\left\\langle \\epsilon_{\\mathbf{q}s} \\right| \\nabla_{\\mathbf{q}} \\Phi(\\mathbf{q})  \\left| \\epsilon_{\\mathbf{q}s} \\right\\rangle \\end{equation} \\] <p>where the derivatives of the dynamical matrix are defined above, and</p> \\[ \\begin{equation} \\mathbf{v}_{\\mathbf{q}s} = \\nabla_{\\mathbf{q}} \\omega_s(\\mathbf{q})= \\frac{1}{2\\omega_s} \\nabla_{\\mathbf{q}} \\omega_s^2(\\mathbf{q}) \\end{equation} \\] <p>For degenerate modes this is ill-defined, we have to apply degenerate perturbation theory to resolve it. The practical procedure is as follows (this example is for a single component, but the same procedure works in general), first define</p> \\[ \\begin{equation}     h_{ij} =     \\left\\langle \\epsilon_{\\mathbf{q}i} \\right|     \\partial_{q_{\\alpha}} \\Phi(\\mathbf{q})  \\left| \\epsilon_{\\mathbf{q}j} \\right\\rangle \\end{equation} \\] <p>where the indices run over the degenerate subspace. The gradient is then</p> \\[ \\begin{equation}     \\partial_{q_{\\alpha}} \\omega^{2}_{\\mathbf{q}i} = \\frac{1}{N} \\sum_{i} \\lambda_{i} \\end{equation} \\] <p>where \\(\\lambda_i\\) are the eigenvalues of \\(h_{ij}\\).</p> <p>The Hessian with respect to \\(q\\) is given via</p> \\[ \\begin{align}     \\frac{\\partial^2 \\omega^{2}_{\\lambda}}{\\partial q_{\\alpha} \\partial q_{\\beta}} &amp; =     2\\left\\langle \\epsilon_{\\lambda} \\right|         \\partial_{q_{\\alpha}}\\partial_{q_{\\beta}}\\Phi(\\mathbf{q})     \\left| \\epsilon_{\\lambda} \\right\\rangle +     \\left\\langle \\epsilon_{\\lambda} \\right| \\partial_{q_{\\alpha}}\\Phi(\\mathbf{q}) \\left| \\partial_{q_{\\beta}} \\epsilon_{\\lambda} \\right\\rangle     +     \\left\\langle \\epsilon_{\\lambda} \\right| \\partial_{q_{\\beta}}\\Phi(\\mathbf{q}) \\left| \\partial_{q_{\\alpha}} \\epsilon_{\\lambda} \\right\\rangle     %     \\\\     %     \\frac{\\partial^2 \\omega_{\\lambda}}{\\partial q_{\\alpha} \\partial q_{\\beta}} &amp; = \\frac{1}{2\\omega_{\\lambda}}     \\left[         \\frac{\\partial^2 \\omega^{2}_{\\lambda}}{\\partial q_{\\alpha} \\partial q_{\\beta}} -         2 \\frac{\\partial \\omega_{\\lambda}}{\\partial q_{\\alpha}} \\frac{\\partial \\omega_{\\lambda}}{\\partial q_{\\beta}}     \\right] \\end{align} \\] <p>The mode Gr\u00fcneisen parameters are a measure of the sensitivity of the vibrational frequencies to volume changes. They are given by</p> \\[ \\begin{equation} \\gamma_{\\mathbf{q}s}=-\\frac{V}{\\omega_{\\mathbf{q}s}}\\frac{\\partial \\omega_{\\mathbf{q}s}}{\\partial V} \\end{equation} \\] <p>where \\(V\\) is the volume and \\(\\omega_{\\mathbf{q}s}\\) is the frequency of mode \\(s\\) at wave vector \\(\\mathbf{q}\\). \\(\\gamma_{\\mathbf{q}s}\\) can be obtained either by numerical differentiation of the phonon dispersion relations or from the third order force constants based on a perturbation approach:</p> \\[ \\begin{equation} \\gamma_{\\mathbf{q}s}=-\\frac{1}{6\\omega_{\\mathbf{q}s}^2}\\sum_{ijk\\alpha\\beta\\gamma} \\frac{\\epsilon^{i\\alpha\\dagger}_{\\mathbf{q}s} \\epsilon^{j\\beta}_{\\mathbf{q}s}} {\\sqrt{m_i m_j}} r_k^\\gamma \\Phi_{ijk}^{\\alpha\\beta\\gamma}e^{i\\mathbf{q}\\cdot\\ \\mathbf{r}_j} \\end{equation} \\] <p>Here \\(\\epsilon_{i\\alpha}^{\\mathbf{q}s}\\) is component \\(\\alpha\\) associated eigenvector \\(\\epsilon\\) for atom \\(i\\). \\(m_i\\) is the mass of atom \\(i\\), and \\(\\mathbf{r}_i\\) is the vector locating its position.</p>"},{"location":"program/phonon_dispersion_relations/#density-of-states","title":"Density of states","text":"<p>Using <code>--dos</code> or will calculate the phonon density of states, given by</p> \\[ g_s(\\omega) = \\frac{(2\\pi)^3}{V} \\int_{\\mathrm{BZ}} \\delta( \\omega - \\omega_{\\mathbf{q}s}) d\\mathbf{q} \\] <p>per mode \\(s\\), summing those up yields the total. The site projected density of states for site \\(i\\) is given by</p> \\[ g_i(\\omega) = \\frac{(2\\pi)^3}{V} \\sum_{s} \\int_{\\mathrm{BZ}} \\left|\\epsilon^i_{\\mathbf{q}s}\\right|^2 \\delta( \\omega -  \\omega_{\\mathbf{q}s}) d\\mathbf{q} \\] <p>that, also sums to the total density of states.</p>"},{"location":"program/phonon_dispersion_relations/#input-files","title":"Input files","text":"<ul> <li>infile.ucposcar</li> <li>infile.forceconstant</li> </ul> <p>Optional files:</p> <ul> <li>infile.qpoints_dispersion (to specify a path for the phonon dispersions)</li> <li>infile.forceconstant_thirdorder (for the Gr\u00fcneisen parameter)</li> </ul>"},{"location":"program/phonon_dispersion_relations/#output-files","title":"Output files","text":"<p>Depending on options, the set of output files may differ. We start with the basic files that are written.</p>"},{"location":"program/phonon_dispersion_relations/#outfiledispersion_relationshdf5","title":"<code>outfile.dispersion_relations.hdf5</code>","text":"<p>This is a packed up format of all the data. Below is a short matlab snippet to plot parts of it, the hdf5 file is self-explanatory -- it contains all harmonic properties you can think of including some more.</p> <pre><code>fn='outfile.dispersion_relations.hdf5';\nx=h5read(fn,'/q_values');\nxtck=h5read(fn,'/q_ticks');\nxtckl=strsplit(h5readatt(fn,'/','q_tick_labels'));\ny=h5read(fn,'/frequencies');\nfrequnit=h5readatt(fn,'/frequencies','unit');\nfigure(1); clf; hold on; box on;\nplot(x,y)\nset(gca,'xtick',xtck,'xticklabel',xtckl,'yminortick','on');\nylabel(['Frequencies (' frequnit ')'])\nxlim([0 max(x)])\n</code></pre> <p></p>"},{"location":"program/phonon_dispersion_relations/#outfilephonon_doshdf5","title":"'outfile.phonon_dos.hdf5'","text":"<p>Contains the phonon density of states. The file is self-documented, below is a sample matlab snippet that plots it.</p> PythonMatlab <pre><code>hej\n</code></pre> <pre><code>fn=('outfile.phonon_dos.hdf5');\nunique_atom_labels=strsplit(h5readatt(fn,'/','unique_atom_labels'));\nenergy_unit=h5readatt(fn,'/frequencies','unit');\ndos_unit=h5readatt(fn,'/dos','unit')\nomega=h5read(fn,'/frequencies');\ndos=h5read(fn,'/dos');\ndos_per_mode=h5read(fn,'/dos_per_mode');\ndos_per_site=h5read(fn,'/dos_per_site');\ndos_per_unique_atom=h5read(fn,'/dos_per_unique_atom');\nfigure(1); clf;\nsubplot(1,3,1); hold on; box on;\ntitle('Phonon density of states')\nfor i=1:size(dos_per_mode,2)\nplot(omega,dos)\nend\nset(gca,'xminortick','on','yminortick','on')\nylabel(['Phonon density of states (' dos_unit ')'])\nxlabel(['Frequency (' energy_unit ')'])\nsubplot(1,3,2); hold on; box on;\ntitle('Phonon density of states per mode')\nfor i=1:size(dos_per_mode,2)\nplot(omega,dos_per_mode(:,i))\nend\nset(gca,'xminortick','on','yminortick','on')\nylabel(['Phonon density of states (' dos_unit ')'])\nxlabel(['Frequency (' energy_unit ')'])\nsubplot(1,3,3); hold on; box on;\ntitle('Phonon density of states per unique atom')\ny=zeros(size(omega));\nfor i=1:size(dos_per_unique_atom,2)\ny=y+dos_per_unique_atom(:,i)\nplot(omega,y)\nend\nl=legend(unique_atom_labels);\nset(l,'edgecolor','none','location','northwest')\nset(gca,'xminortick','on','yminortick','on')\nylabel(['Phonon density of states (' dos_unit ')'])\nxlabel(['Frequency (' energy_unit ')'])\n</code></pre>"},{"location":"program/phonon_dispersion_relations/#outfiledispersion_relations","title":"<code>outfile.dispersion_relations</code>","text":"<p>This file contains a list of \\(q\\) points (in 1/\u00c5) according to the chosen path (default or specified by the user in <code>infile.qpoints_dispersions</code>) and the frequencies per mode (in the specified units via <code>--unit</code>) for the corresponding points.</p> Row Description 1      \\( q_1 \\qquad \\omega_1 \\qquad \\omega_2 \\qquad \\ldots \\qquad \\omega_{3N_a} \\)      2      \\( q_2 \\qquad \\omega_1 \\qquad \\omega_2 \\qquad \\ldots \\qquad \\omega_{3N_a} \\)     ... ... <p>Not that the first column is for plotting purposes only. It serves to ensure that each line segment is scaled properly, since each segment contains a fix number of points.</p>"},{"location":"program/phonon_dispersion_relations/#outfilegroup_velocities","title":"<code>outfile.group_velocities</code>","text":"<p>This file contains the norm of the group velocities as a function of q. Format is identical to that of the dispersions:</p> Row Description 1      \\( q_1 \\qquad |v_1| \\qquad |v_2| \\qquad \\ldots \\qquad |v_{3N_a}| \\)      2      \\( q_2 \\qquad |v_1| \\qquad |v_2| \\qquad \\ldots \\qquad |v_{3N_a}| \\)  ... ... <p>The units are in km/s.</p>"},{"location":"program/phonon_dispersion_relations/#outfilemode_gruneisen_parameters","title":"<code>outfile.mode_gruneisen_parameters</code>","text":"<p>In case you used <code>--gruneisen</code>, the mode Gr\u00fcneisen parameters will be written, in a format similar to the dispersions and group velocities:</p> Row Description 1      $ q_1 \\qquad \\gamma_1 \\qquad \\gamma_2 \\qquad \\ldots \\qquad \\gamma_{3N_a} $      2      $ q_2 \\qquad \\gamma_1 \\qquad \\gamma_2 \\qquad \\ldots \\qquad \\gamma_{3N_a} $   ... ... <p>The units are in km/s.</p> <p></p>"},{"location":"program/phonon_dispersion_relations/#outfilephonon_dos","title":"<code>outfile.phonon_dos</code>","text":"<p>The first column is the list of frequencies and the second column in the density of states for this frequency, given in arbitrary units. Note that integrated density of states is normalized. One can calculate partial density of states (<code>--projected_dos_mode</code>); if the user specifies this option, an extra column will be added into the <code>outfile.phonon_dos</code> file for each type of atom. With <code>--projected_dos_site</code> the same thing happens but with an extra column for each atom in the unit cell.</p> Row Description 1      $ \\omega_1 \\qquad g(\\omega_1) \\qquad g_1(\\omega_1) \\qquad \\ldots \\qquad g_{N}(\\omega_1) $      2      $ \\omega_2 \\qquad g(\\omega_2) \\qquad g_1(\\omega_2) \\qquad \\ldots \\qquad g_{N}(\\omega_2) $      ... ... <p>The units are in states per energy unit, depending on choice of <code>--unit</code>. The total DOS normalizes to 3N independent of choice of unit.</p>"},{"location":"program/phonon_dispersion_relations/#outfilefree_energy","title":"<code>outfile.free_energy</code>","text":"<p>If one chooses the option <code>--temperature_range</code> or <code>--temperature</code> then this file will display a list of temperatures with corresponding temperatures, vibrational free energies, vibrational entropies and heat capacities.</p> Row Description 1      $ T_1 \\qquad F_{\\textrm{vib}} \\qquad S_{\\textrm{vib}} \\qquad C_v $      2      $ T_2 \\qquad F_{\\textrm{vib}} \\qquad S_{\\textrm{vib}} \\qquad C_v $      ... ... <p>Temperature is given in K, \\( F_{\\textrm{vib}} \\) in eV/atom, \\( S_\\textrm{vib} \\) in eV/K/atom and heat capacity in eV/K/atom.</p>"},{"location":"program/phonon_dispersion_relations/#outfilegrid_dispersionshdf5","title":"<code>outfile.grid_dispersions.hdf5</code>","text":"<p>Using option <code>--dumpgrid</code> writes all phonon properties for a grid in the BZ to an hdf5 file, that is self-documented.</p> <ol> <li> <p>Born, M., &amp; Huang, K. (1964). Dynamical theory of crystal lattices. Oxford: Oxford University Press.\u00a0\u21a9</p> </li> <li> <p>Hellman, O., Abrikosov, I. A., &amp; Simak, S. I. (2011). Lattice dynamics of anharmonic solids from first principles. Physical Review B, 84(18), 180301. \u21a9</p> </li> <li> <p>Hellman, O., &amp; Abrikosov, I. A. (2013). Temperature-dependent effective third-order interatomic force constants from first principles. Physical Review B, 88(14), 144301. \u21a9</p> </li> <li> <p>Hellman, O., Steneteg, P., Abrikosov, I. A., &amp; Simak, S. I. (2013). Temperature dependent effective potential method for accurate free energy calculations of solids. Physical Review B, 87(10), 104111. \u21a9</p> </li> <li> <p>Gonze, X., Charlier, J.-C., Allan, D. C. &amp; Teter, M. P. Interatomic force constants from first principles: The case of \u03b1-quartz. Phys. Rev. B 50, 13035\u201313038 (1994). \u21a9</p> </li> <li> <p>Gonze, X. &amp; Lee, C. Dynamical matrices, Born effective charges, dielectric permittivity tensors, and interatomic force constants from density-functional perturbation theory. Phys. Rev. B 55, 10355\u201310368 (1997). \u21a9\u21a9</p> </li> </ol>"},{"location":"program/refine_structure/","title":"Refine structure","text":""},{"location":"program/refine_structure/#short-description","title":"Short description","text":"<p>Small utility to ensure that the input structure satisfies all symmetries to high precision.</p>"},{"location":"program/refine_structure/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--tolerance_lattice value</code>, <code>-tl value</code>     default value 1E-5     Tolerance for the lattice.</p> </li> <li> <p><code>--tolerance_internal value</code>, <code>-ti value</code>     default value 1E-5     Tolerance for internal degrees of freedom.</p> </li> <li> <p><code>--unitcell value</code>, <code>-uc value</code>     default value infile.ucposcar     Filename for the unitcell to refine.</p> </li> <li> <p><code>--supercell value</code>, <code>-ss value</code>     default value none     Filename for supercell to refine.</p> </li> <li> <p><code>--prototype value</code>, <code>-pf value</code>     default value none     Prototype unitcell where you know the symmetry is correct.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/refine_structure/#examples","title":"Examples","text":"<p><code>refine_structure</code> </p>"},{"location":"program/refine_structure/#longer-summary","title":"Longer summary","text":"<p>This is a utility to ensure that the symmetries of the crystal structure is satisfied to as high precision as possible. A vast majority of issues users experience, can be solved with this tool.</p> <p>In essence, it takes an input crystal structure that might be specified like this</p> <pre><code>hcp Fe\n 2.4\n   0.50000  -0.866025  0.00000\n   0.50000   0.866025  0.00000\n   0.00000   0.000000  1.63299\nFe\n   2\nDirect\n   0.333333   0.66666   0.25000\n   0.666666   0.33333   0.75000\n</code></pre> <p>And returns</p> <pre><code>hcp Fe\n       2.399999720250\n    0.50000000000000    -0.86602540378444     0.00000000000000\n    0.50000000000000     0.86602540378444     0.00000000000000\n    0.00000000000000     0.00000000000000     1.63299057103649\n Fe\n 2\nDirect coordinates\n  0.33333333333333   0.66666666666667   0.25000000000000  site 1 species 1: Fe\n  0.66666666666667   0.33333333333333   0.75000000000000  site 2 species 1: Fe\n</code></pre> <p>Note</p> <p>Explain that we can use a prototype structure to determine the spacegroup, as in pick spacegroup from a unit cell I know is ok, and impose that on the current cell.</p>"},{"location":"program/samples_from_md/","title":"Samples from MD","text":""},{"location":"program/samples_from_md/#short-description","title":"Short description","text":"<p>Choose representative uncorrelated samples from an MD simulation. The samples are chosen to be approximately evenly spaced, and reproduce the average potential energy, average kinetic energy have the same standard deviation of potential and kinetic energy.</p>"},{"location":"program/samples_from_md/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--nsamples value</code>, <code>-n value</code>     default value 50     Number of samples</p> </li> <li> <p><code>--output_format value</code>, <code>-of value</code>, value in: <code>1,2,3,4</code>     default value 1     Output format. 1 is VASP, 2 Abinit, 3 LAMMPS, 4 FHI-AIMS.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/samples_from_md/#examples","title":"Examples","text":"<p><code>samples_from_md -n 100</code> </p>"},{"location":"program/samples_from_md/#longer-summary","title":"Longer summary","text":"<p>Ab initio molecular dynamics are expensive calculations. There will be a tradeoff between numerical precision and the number of timesteps. To work around this, you can run the MD with rather low precision and gather statistics. Then, from the long simulation, choose a set of uncorrelated configurations and recalculate these with high precision.</p> <p>From these low accuracy calculations we choose a set of \\(n\\) uncorrelated samples and correct scalar parameter \\(a\\) as</p> \\[ \\begin{equation} a = &lt;a^l&gt; + \\frac{1}{n}\\sum_{i=1}^n a^h_i-a_i^l, \\end{equation} \\] <p>where \\(a^l\\) are the low accuracy calculations and \\(a^h\\) are calculations done with high accuracy. This exploits the fact that most omissions of numerical accuracy, such as basis set and k-point selection, lead to additive errors. This technique is well suited to determine the interatomic force constants and resulting thermodynamic/transport properties with high accuracy.</p> <p>This code selects a choice of uncorrelated samples from BOMD via a Monte-Carlo algorithm, assuring the selection is not biased. We start with a calculation of average potential \\(E_p\\), kinetic energies \\(E_k\\), and their standard deviation. We check the distance between samples assuring that chosen samples are not temporally adjacent. The results of this procedure is written in output files (<code>outfile.stat_sample</code>). The average values and distance between selected points depend on the number of desired samples.</p>"},{"location":"program/samples_from_md/#input-files","title":"Input files","text":"<ul> <li>infile.ucposcar</li> <li>infile.ssposcar</li> <li>infile.meta</li> <li>infile.stat</li> <li>infile.positions</li> <li>infile.forces</li> </ul>"},{"location":"program/samples_from_md/#output-files","title":"Output files","text":"<p>This code will generate a series of structures in the specified output format.</p>"},{"location":"program/thermal_conductivity/","title":"Thermal conductivity","text":""},{"location":"program/thermal_conductivity/#short-description","title":"Short description","text":"<p>Calculates the lattice thermal conductivity from the iterative solution of the phonon Boltzmann equation. In addition, cumulative plots and raw data dumps of intermediate values are available.</p>"},{"location":"program/thermal_conductivity/#command-line-options","title":"Command line options:","text":"<p>Optional switches:</p> <ul> <li> <p><code>--readiso</code>     default value .false.     Read the isotope distribution from <code>infile.isotopes</code>. The format is specified here.</p> </li> <li> <p><code>--qpoint_grid value#1 value#2 value#3</code>, <code>-qg value#1 value#2 value#3</code>     default value 26 26 26     Density of q-point mesh for Brillouin zone integrations.</p> </li> <li> <p><code>--integrationtype value</code>, <code>-it value</code>, value in: <code>1,2,3</code>     default value 2     Type of integration for the phonon DOS. 1 is Gaussian, 2 adaptive Gaussian and 3 Tetrahedron.</p> </li> <li> <p><code>--sigma value</code>     default value 1.0     Global scaling factor for adaptive Gaussian smearing.</p> </li> <li> <p><code>--threshold value</code>     default value 4.0     Consider a Gaussian distribution to be 0 after this many standard deviations.</p> </li> <li> <p><code>--readqmesh</code>     default value .false.     Read the q-point mesh from file. To generate a q-mesh file, see the genkpoints utility.</p> </li> <li> <p><code>--temperature value</code>     default value -1     Evaluate thermal conductivity at a single temperature.</p> </li> <li> <p><code>--temperature_range value#1 value#2 value#3</code>     default value 100 300 5     Series of temperatures for thermal conductivity. Specify min, max and the number of points.</p> </li> <li> <p><code>--logtempaxis</code>     default value .false.     Space the temperature points logarithmically instead of linearly.</p> </li> <li> <p><code>--max_mfp value</code>     default value -1     Add a limit on the mean free path as an approximation of domain size.</p> </li> <li> <p><code>--dumpgrid</code>     default value .false.     Write files with q-vectors, frequencies, eigenvectors and group velocities for a grid.</p> </li> <li> <p><code>--noisotope</code>     default value .false.     Do not consider isotope scattering.</p> </li> <li> <p><code>--help</code>, <code>-h</code>     Print this help message</p> </li> <li> <p><code>--version</code>, <code>-v</code>     Print version</p> </li> </ul>"},{"location":"program/thermal_conductivity/#examples","title":"Examples","text":"<p><code>mpirun thermal_conductivity --temperature 300</code> </p> <p><code>mpirun thermal_conductivity -qg 15 15 15 --temperature_range 200 600 50</code> </p> <p><code>mpirun thermal_conductivity --integrationtype 2 -qg 30 30 30 --max_mfp 1E-6</code>  author: Olle Hellman display: none graph: none propname: thermal conductivity propnamelink: thermal conductivity {!man/thermal_conductivity.md!}</p>"},{"location":"program/thermal_conductivity/#what-can-this-code-produce","title":"What can this code produce","text":"<p>@todo Add plot of kappa vs temperature</p> <p>@todo Add plot with kappa vs boundary scattering?</p> <p>@todo Add plot with spectral kappa</p> <p>@todo Add plot with scattering rates</p>"},{"location":"program/thermal_conductivity/#longer-summary","title":"Longer summary","text":"<p>@todo Revise, rather confusing at the moment.</p> <p>@todo Start from the proper Boltzmann equation.</p> <p>Heat transport can be determined by solving the inelastic phonon Boltzmann equation. By applying a temperature gradient \\(\\nabla T_\\alpha\\) in direction \\(\\alpha\\), the heat current is given by the group velocities of phonon mode \\(\\lambda\\) and non-equilibrium phonon distribution function \\(\\tilde{n}_\\lambda\\):[^peierls1955quantum]</p> \\[ \\begin{equation} J_{\\alpha}=\\frac{1}{V}\\sum_\\lambda \\hbar \\omega_\\lambda v_{\\lambda\\alpha} \\tilde{n}_{\\lambda\\alpha}. \\end{equation} \\] <p>Assuming the thermal gradient is small, the non-equilibrium distribution function can be linearised as,</p> \\[ \\tilde{n}_{\\lambda\\alpha} \\approx n_{\\lambda}- v_{\\lambda\\alpha} \\tau_{\\lambda\\alpha} \\frac{d n_{\\lambda}}{d T} \\frac{d T}{d \\alpha} \\, , \\] <p>That is a linear deviation from the equilibrium distribution function \\(n_{\\lambda}\\). Inserting this into the equation 1, and exploiting the fact that the equilibrium occupation carries no heat, we arrive at,</p> \\[ J_{\\alpha}=\\frac{1}{V}\\sum_{\\lambda} \\hbar \\omega_{\\lambda} \\frac{d n_{\\lambda}}{d T} v_{\\lambda\\alpha} v_{\\lambda\\alpha} \\tau_{\\lambda\\alpha} \\frac{d T}{d \\alpha}. \\] <p>Utilizing Fourier's law, \\(J=\\kappa \\nabla T\\), and identifying the phonon heat capacity,</p> \\[ c_{\\lambda}= \\hbar \\omega_\\lambda \\frac{d n_{\\lambda}}{d T}, \\] <p>we arrive at,</p> \\[ \\kappa_{\\alpha\\beta}=\\frac{1}{V} \\sum_{\\lambda} c_{\\lambda} v_{\\alpha \\lambda}v_{\\beta \\lambda} \\tau_{\\beta \\lambda}, \\] <p>which can be interpreted as follows: the heat transported by each phonon will depend on how much heat it carries, how fast it travels, and how long it lives. The phonon-phonon induced lifetime can be determined from the self-energy \\(\\Gamma_{\\lambda}\\). In addition, one must consider the scattering with mass impurities (isotopes), and the boundaries of the sample.</p>"},{"location":"program/thermal_conductivity/#lifetimes","title":"Lifetimes","text":"<p>With the third order force constants we can calculate the phonon lifetimes needed as input to the thermal conductivity calculations. The lifetime due to phonon-phonon scattering is related to the imaginary part of the phonon self energy ( \\(\\Sigma=\\Delta+i\\Gamma\\) ).</p> \\[ \\frac{1}{\\tau_{\\lambda}}=2 \\Gamma_{\\lambda}, \\] <p>where \\(\\tau_{\\lambda}\\) is the lifetime phonon mode \\(\\lambda\\), and</p> \\[ \\begin{split} \\Gamma_{\\lambda}=&amp; \\frac{\\hbar \\pi}{16} % _{\\lambda'} \\sum_{\\lambda'\\lambda''} \\left|\\Phi_{\\lambda\\lambda'\\lambda''}\\right|^2 \\bigl[(n_{\\lambda'}+n_{\\lambda''}+1) \\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\\\ + &amp; 2(n_{\\lambda'}-n_{\\lambda''}) \\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}+\\omega_{\\lambda''}) \\bigr] \\end{split} \\] <p>\\(n_{\\lambda}\\) is the equilibrium occupation number. The sum is over momentum conserving three-phonon processes, \\(\\textbf{q}+\\textbf{q}'+\\textbf{q}''=\\textbf{G}\\), and the deltafunctions in frequency ensure energy conservation. The three-phonon matrix elements are given by</p> \\[ \\Phi_{\\lambda\\lambda'\\lambda''} = \\sum_{ijk} \\sum_{\\alpha\\beta\\gamma} \\frac{ \\epsilon_{\\lambda}^{i \\alpha} \\epsilon_{\\lambda'}^{j \\beta} \\epsilon_{\\lambda''}^{k \\gamma} }{ \\sqrt{m_{i}m_{j}m_{j}} \\sqrt{     \\omega_{\\lambda}     \\omega_{\\lambda'}     \\omega_{\\lambda''}} } \\Phi^{\\alpha\\beta\\gamma}_{ijk} e^{i \\mathbf{q}\\cdot\\mathbf{r}_i + i \\mathbf{q}'\\cdot\\mathbf{r}_j+i \\mathbf{q}''\\cdot\\mathbf{r}_k} \\] <p>where \\(m_i\\) is the mass of atom \\(i\\), \\(\\epsilon_{\\lambda}^{\\alpha i}\\) is component \\(\\alpha\\) of the eigenvector for mode \\(\\lambda\\) and atom \\(i\\) and \\(\\textbf{r}_i\\) is the lattice vector associated with atom \\(i\\).</p> <p>Mass disorder, in the form of natural isotope distributions also cause thermal resistance. According to Tamura[^Tamura1983], if the isotopes are randomly distributed on the lattice sites then the strength of the isotope scattering can be given by a mass variance parameter \\(g\\):</p> \\[ g_i=\\sum_j c_{i}^j \\left(\\frac{m_i^j-\\bar{m_i}}{\\bar{m_i}}\\right)^2 \\] <p>where \\(\\bar{m_i}\\) is the average isotopic mass( \\(\\bar{m_i}=\\sum_j c_i^j m_i^j\\) ), \\(m^j_i\\) is the mass of isotope \\(j\\) of atom \\(i\\) and \\(c^j_i\\) is its concentration. The contribution to the imaginary part of the self-energy is</p> \\[ \\Gamma^{\\textrm{iso}}_{\\lambda}= \\frac{\\pi}{4} \\sum_{\\lambda'} \\underbrace{\\omega_{\\lambda}\\omega_{\\lambda'} \\sum_i g_i \\left| \\epsilon_{\\lambda}^{i \\dagger} \\epsilon_{\\lambda'}^{i} \\right|^2}_{\\Lambda_{\\lambda\\lambda'}} \\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}) \\] <p>Per default, the isotope distribution will be the natural distribution. In case some other distribution is desired, this can be specified.</p> <p>Scattering by domain boundaries is implemented as</p> \\[ \\Gamma^{\\textrm{boundary}}_{\\lambda} = \\frac{ v_{\\lambda} }{2d} \\] <p>Where \\(d\\) is a characteristic domain size.</p>"},{"location":"program/thermal_conductivity/#beyond-the-relaxation-time-approximation","title":"Beyond the relaxation time approximation","text":"<p>So far we have have considered the phonon heat conduction as an elastic process, whereas it is inelastic. This can be treated by iteratively solving the phonon boltzmann equation, formulated in terms of the (linear) deviations from equilibrium occupation numbers.[^peierls1929],[^Omini1996],[^Omini],[^Broido2007],[^Broido2005]</p> <p> </p> Phonon scattering rates and the phonon Boltzmann equation   I always found it confusing how you arrived at most of these things. This is something I put together for myself, to clear it up a bit. Please bear in mind that this is not an attempt at a formal derivation whatsoever, just to make it a bit easier to interpret the different terms. There might be an arbitrary number of plusses and minuses and other things missing. Recall the transformation we introduced [earlier](../program/phonon_dispersion_relations.html):  $$ \\begin{equation}\\label{eq:normalmodetransformation} \\hat{u}_{i\\alpha} = \\sqrt{ \\frac{\\hbar}{2N m_\\alpha} } \\sum_\\lambda \\frac{\\epsilon_\\lambda^{i\\alpha}}{ \\sqrt{ \\omega_\\lambda} } e^{i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\hat{a}^{\\mathstrut}_\\lambda + \\hat{a}^\\dagger_\\lambda \\right) \\end{equation} $$  and consider the three-phonon process where two phonons combine into one:  $$ \\begin{equation*} \\begin{split} \\mathbf{q} + \\mathbf{q}' + \\mathbf{q}'' &amp; = \\mathbf{G} \\\\ \\omega + \\omega' &amp; = \\omega'' \\end{split} \\end{equation*} $$  This process changes the state of the system:  $$ \\begin{equation} \\underbrace{\\left| \\ldots , n_{\\lambda},n_{\\lambda'},n_{\\lambda''} , \\ldots \\right\\rangle}_{\\left\\vert i \\right\\rangle} \\rightarrow \\underbrace{\\left| \\ldots , n_{\\lambda}-1,n_{\\lambda'}-1,n_{\\lambda''}+1, \\ldots \\right\\rangle}_{\\left\\vert f \\right\\rangle} \\end{equation} $$  that is, we lost one phonon at $\\lambda$ and one at $\\lambda'$, and created a phonon at $\\lambda''$. Mostly out of habit, we sandwich the Hamiltonian between the initial and final states:  $$ \\begin{equation}\\label{eq:sandwich} {\\left\\langle f \\middle\\vert \\hat{H} \\middle\\vert i \\right\\rangle} = {\\left\\langle f \\middle\\vert \\sum_i \\frac{p^2_i}{2m}  + \\frac{1}{2!}\\sum_{ij} \\sum_{\\alpha\\beta}\\Phi_{ij}^{\\alpha\\beta} u_i^\\alpha u_j^\\beta +\\frac{1}{3!} \\sum_{ijk} \\sum_{\\alpha\\beta\\gamma}\\Phi_{ijk}^{\\alpha\\beta\\gamma} u_i^\\alpha u_j^\\beta u_k^\\gamma \\ldots \\middle\\vert i \\right\\rangle} \\end{equation} $$  and remember the rules for ladder operators, and that the eigenstates to the quantum harmonic oscillator are orthogonal:  $$ \\begin{equation*} \\begin{split} \\hat{a}^\\dagger \\left\\vert n \\right\\rangle &amp; = \\sqrt{n+1} \\left\\vert n + 1 \\right\\rangle \\\\ \\hat{a} \\left\\vert n \\right\\rangle &amp; = \\sqrt{n} \\left\\vert n -1 \\right\\rangle \\\\ \\left\\langle i \\middle\\vert j \\right\\rangle &amp; = \\delta_{ij} \\end{split} \\end{equation*} $$  Inserting eq \\ref{eq:normalmodetransformation} into \\ref{eq:sandwich} (and realising that the kinetic energy part and the second order part disappears), we end up with a pretty large expression, that we will deal with in steps, first identify  $$ \\begin{equation}\\label{eq:uprod} \\begin{split} u^\\alpha_{i}u^\\beta_{j}u^\\gamma_{k} &amp; = % \\left(\\frac{\\hbar}{2N}\\right)^{3/2} \\frac{1}{\\sqrt{m_{i}m_{j}m_{k}}} \\sum_{\\lambda\\lambda'\\lambda''} \\frac{ \\epsilon_{\\lambda}^{i \\alpha} \\epsilon_{\\lambda'}^{j \\beta} \\epsilon_{\\lambda''}^{k \\gamma} }{ \\sqrt{     \\omega_{\\lambda}     \\omega_{\\lambda'}     \\omega_{\\lambda''}} } e^{i \\mathbf{q}\\cdot\\mathbf{r}_i + i \\mathbf{q}'\\cdot\\mathbf{r}_j+i \\mathbf{q}''\\cdot\\mathbf{r}_k}  \\left(a_{\\lambda}+a_{\\lambda}^\\dagger \\right) \\left(a_{\\lambda'}+a_{\\lambda'}^\\dagger \\right) \\left(a_{\\lambda''}+a_{\\lambda''}^\\dagger \\right) \\end{split} \\end{equation} $$  as well as  $$ \\begin{equation} \\begin{split} &amp; \\sum_{\\lambda\\lambda'\\lambda''} \\left\\langle f \\middle\\vert   \\left(a_{\\lambda}+a_{\\lambda}^\\dagger \\right) \\left(a_{\\lambda'}+a_{\\lambda'}^\\dagger \\right) \\left(a_{\\lambda''}+a_{\\lambda''}^\\dagger \\right) \\middle\\vert i \\right\\rangle = \\\\ = &amp; \\sum_{\\lambda\\lambda'\\lambda''} \\left\\langle f \\middle\\vert \\hat{a}_{\\lambda}   \\hat{a}_{\\lambda'}   \\hat{a}_{\\lambda''} + \\hat{a}_{\\lambda}   \\hat{a}_{\\lambda'}   \\hat{a}^{\\dagger}_{\\lambda''} + \\hat{a}_{\\lambda}   \\hat{a}^{\\dagger}_{\\lambda'}   \\hat{a}_{\\lambda''} + \\hat{a}_{\\lambda}   \\hat{a}^{\\dagger}_{\\lambda'}   \\hat{a}^{\\dagger}_{\\lambda''} + \\hat{a}^{\\dagger}_{\\lambda}   \\hat{a}_{\\lambda'}   \\hat{a}_{\\lambda''} + \\hat{a}^{\\dagger}_{\\lambda}   \\hat{a}_{\\lambda'}   \\hat{a}^{\\dagger}_{\\lambda''} + \\hat{a}^{\\dagger}_{\\lambda}   \\hat{a}^{\\dagger}_{\\lambda'}   \\hat{a}_{\\lambda''} + \\hat{a}^{\\dagger}_{\\lambda}   \\hat{a}^{\\dagger}_{\\lambda'}   \\hat{a}^{\\dagger}_{\\lambda''} \\middle\\vert i \\right\\rangle = \\\\ = &amp; \\sum_{\\lambda\\lambda'\\lambda''} \\left\\langle f \\middle\\vert a_{\\lambda}a_{\\lambda'}a^\\dagger_{\\lambda''} \\middle\\vert i \\right\\rangle  = 3 \\sqrt{n_{\\lambda}n_{\\lambda'}(n_{\\lambda''}+1)} \\end{split} \\end{equation} $$  where the factor 3 comes from the multiplicity, to get at  $$ \\begin{equation} {\\left\\langle f \\middle\\vert \\hat{H}_3 \\middle\\vert i \\right\\rangle} = \\frac{1}{2} \\sum_{ijk} \\sum_{\\alpha\\beta\\gamma}\\Phi_{ijk}^{\\alpha\\beta\\gamma} \\sqrt{n_{\\lambda}n_{\\lambda'}(n_{\\lambda''}+1)} % \\left(\\frac{\\hbar}{2N}\\right)^{3/2} \\frac{ \\epsilon_{\\lambda}^{i \\alpha} \\epsilon_{\\lambda'}^{j \\beta} \\epsilon_{\\lambda''}^{k \\gamma} }{ \\sqrt{m_{i}m_{j}m_{j}} \\sqrt{     \\omega_{\\lambda}     \\omega_{\\lambda'}     \\omega_{\\lambda''}} } e^{i \\mathbf{q}\\cdot\\mathbf{r}_i + i \\mathbf{q}'\\cdot\\mathbf{r}_j+i \\mathbf{q}''\\cdot\\mathbf{r}_k} \\end{equation} $$  The initial factor 1/2 is the multiplicity cancelled by the 3! from the Hamiltonian. Here, as it happens, we can identify the three-phonon matrix elements and simplify a little bit more  $$ \\begin{equation} {\\left\\langle f \\middle\\vert \\hat{H}_3 \\middle\\vert i \\right\\rangle} = \\frac{1}{2} \\sqrt{n_{\\lambda}n_{\\lambda'}(n_{\\lambda''}+1)} \\left(\\frac{\\hbar}{2N}\\right)^{3/2} \\Phi_{\\lambda\\lambda'\\lambda''} \\end{equation} $$  The probability of this particular three-phonon process can be estimated via the Fermi golden rule:  $$ \\begin{equation} \\begin{split} P_{\\lambda\\lambda'\\rightarrow\\lambda''} &amp; =\\frac{2\\pi}{\\hbar} \\left|{\\left\\langle f \\middle\\vert \\hat{H}_3 \\middle\\vert i \\right\\rangle}\\right|^2 \\delta(E_f-E_i) = \\frac{\\hbar^2\\pi}{16N} n_{\\lambda}n_{\\lambda'}(n_{\\lambda''}+1) \\left| \\Phi_{\\lambda\\lambda'\\lambda''} \\right|^2 \\delta(E_f-E_i) \\end{split} \\end{equation} $$  With near identical reasoning, we can also arrive at  $$ \\begin{equation}\\label{pplus} P_{\\lambda\\rightarrow\\lambda'\\lambda''} = \\frac{\\hbar^2\\pi}{16N} n_{\\lambda}(n_{\\lambda'}+1)(n_{\\lambda''}+1) \\left| \\Phi_{\\lambda\\lambda'\\lambda''} \\right|^2 \\delta(E_f-E_i) \\end{equation} $$  for the other kind of three-phonon processes, and  $$ \\begin{equation}\\label{pminus} P_{\\lambda\\rightarrow\\lambda'} =\\frac{2\\pi}{\\hbar}\\left|\\langle f | H^{\\textrm{iso}} | i \\rangle \\right|^2\\delta(E_f-E_i) = \\frac{\\pi\\hbar}{2N}  n_{\\lambda}(n_{\\lambda'}+1) \\Lambda_{\\lambda\\lambda'}\\delta(E_f-E_i) \\end{equation} $$  for the isotope scattering. I leave those derivations as an exercise. The phonon Boltzmann equation is stated as:  $$ \\begin{equation}\\label{eq:pbe} \\frac{\\partial \\tilde{n}_\\lambda}{\\partial T} \\mathbf{v}_\\lambda \\cdot \\nabla T = \\left. \\frac{\\partial \\tilde{n}_\\lambda }{\\partial t} \\right|_{\\mathrm{coll}} \\end{equation} $$  Where $\\tilde{n}$ is the non-equilibrium occupation number. This is ridiculously complicated. To make life easier, we only consider the terms we outlined above as possible collisions. Gathering all possible events that involve mode $\\lambda$ we get  $$ \\begin{equation}\\label{manyprob} \\begin{split} \\left. \\frac{\\partial n_{\\lambda}}{ \\partial t} \\right|_{\\mathrm{coll}} = &amp;  \\sum_{\\lambda'} \\left( P_{\\lambda\\rightarrow\\lambda'}-P_{\\lambda'\\rightarrow\\lambda } \\right) + \\sum_{\\lambda'\\lambda''} - P_{\\lambda  \\rightarrow \\lambda' \\lambda'' } - P_{\\lambda  \\rightarrow \\lambda''\\lambda'  } + P_{\\lambda' \\rightarrow \\lambda  \\lambda'' } + P_{\\lambda' \\rightarrow \\lambda''\\lambda   } + P_{\\lambda''\\rightarrow \\lambda  \\lambda'  } + P_{\\lambda''\\rightarrow \\lambda' \\lambda   } \\\\ &amp; - P_{\\lambda   \\lambda' \\rightarrow \\lambda'' } - P_{\\lambda   \\lambda'' \\rightarrow \\lambda'  } - P_{\\lambda'  \\lambda   \\rightarrow \\lambda'' } + P_{\\lambda'  \\lambda'' \\rightarrow \\lambda   } - P_{\\lambda'' \\lambda   \\rightarrow \\lambda'  } + P_{\\lambda'' \\lambda'  \\rightarrow \\lambda   } \\end{split} \\end{equation} $$  Which does not seem to make life easier. To make it slightly worse, we insert \\ref{pplus} and \\ref{pminus} into this, and at the same time say that the non-equilibrium distribution functions are the equilibrium distributions, plus a (small) deviation:  $$ \\begin{equation} \\tilde{n}_{\\lambda}\\approx n_{\\lambda}+\\epsilon_{\\lambda} \\end{equation} $$  After some [hard work](https://reference.wolfram.com/language/ref/FullSimplify.html), and discarding terms of $\\epsilon^2$ and higher, we get  $$ \\begin{equation} \\begin{split} \\left. \\frac{\\partial n_{\\lambda}}{ \\partial t} \\right|_{\\mathrm{coll}} = &amp; \\sum_{\\lambda'\\lambda''} \\frac{\\hbar\\pi}{8N} \\left| \\Phi_{\\lambda\\lambda'\\lambda''} \\right|^2 \\Big( \\left[ -n_{\\lambda} \\epsilon_{\\lambda'} + n_{\\lambda''} (\\epsilon_{\\lambda} + \\epsilon_{\\lambda'}) + \\epsilon_{\\lambda''} + n_{\\lambda} \\epsilon_{\\lambda''} + n_{\\lambda'} (-\\epsilon_{\\lambda} + \\epsilon_{\\lambda''}) \\right]\\delta(\\omega_{\\lambda}+\\omega_{\\lambda'}-\\omega_{\\lambda''}) + \\\\ &amp; \\left[ \\epsilon_{\\lambda'} + n_{\\lambda} \\epsilon_{\\lambda'} + n_{\\lambda''} (-\\epsilon_{\\lambda} + \\epsilon_{\\lambda'}) - n_{\\lambda} \\epsilon_{\\lambda''} +   n_{\\lambda'} (\\epsilon_{\\lambda} + \\epsilon_{\\lambda''} ) \\right]\\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}+\\omega_{\\lambda''}) - \\\\ &amp; \\left[(1 + n_{\\lambda'} + n_{\\lambda''})\\epsilon_{\\lambda} - n_{\\lambda''}\\epsilon_{\\lambda''} - n_{\\lambda'} \\epsilon_{\\lambda''} + n_{\\lambda} (\\epsilon_{\\lambda'} + \\epsilon_{\\lambda''} )\\right] \\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\Big) \\end{split} \\end{equation} $$  Which does not seem like a lot of help. If we make another substitution, and say that the deviation from equilibrium behaves sort of like the equilibrium (with no loss of generality, just to make life easier):  $$ \\begin{equation} \\epsilon_{\\lambda} = \\frac{\\partial n_{\\lambda} }{\\partial \\omega_\\lambda} \\frac{k_B T}{\\hbar} \\zeta_{\\lambda}=-n_{\\lambda}(n_{\\lambda}+1) \\zeta_{\\lambda} \\end{equation} $$  Inserting this, and more tedious algebra, we get  $$ \\begin{equation} \\begin{split} \\left. \\frac{\\partial n_{\\lambda}}{ \\partial t} \\right|_{\\mathrm{coll}} =&amp; \\frac{\\hbar\\pi}{4N} \\sum_{\\lambda'\\lambda''} \\left| \\Phi_{\\lambda\\lambda'\\lambda''} \\right|^2 \\Big( n_{\\lambda} n_{\\lambda'} (n_{\\lambda''}+1) \\delta(\\omega_{\\lambda}+\\omega_{\\lambda'}-\\omega_{\\lambda''} ) \\left( \\zeta_{\\lambda} + \\zeta_{\\lambda'} - \\zeta_{\\lambda''} \\right) + \\\\ &amp; \\frac{1}{2} n_{\\lambda} (n_{\\lambda'}+1) (n_{\\lambda''}+1) \\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\left( \\zeta_{\\lambda} - \\zeta_{\\lambda'} -\\zeta_{\\lambda''} \\right) \\Big) \\end{split} \\end{equation} $$  If we add the isotope term again, that I forgot at some point between the beginning and here, we can rearrange this in terms of scattering rates that should look familiar (using strange relations for occupation numbers that only hold when the deltafunctions in energy are satisfied):  $$ \\begin{equation} \\left. \\frac{\\partial n_{\\lambda}}{ \\partial t} \\right|_{\\mathrm{coll}} = \\sum_{\\lambda'\\lambda''} \\tilde{P}^{+}_{\\lambda\\lambda'\\lambda''} \\left( \\zeta_{\\lambda}+\\zeta_{\\lambda'}-\\zeta_{\\lambda''} \\right) +\\frac{1}{2}\\tilde{P}^{-}_{\\lambda\\lambda'\\lambda''} \\left( \\zeta_{\\lambda}-\\zeta_{\\lambda'}-\\zeta_{\\lambda''} \\right)+ \\sum_{\\lambda'} \\tilde{P}^\\textrm{iso}_{\\lambda\\lambda'} \\left( \\zeta_{\\lambda}-\\zeta_{\\lambda'} \\right) \\end{equation} $$  where  $$ \\begin{align} \\tilde{P}^{+}_{\\lambda\\lambda'\\lambda''}&amp;= \\frac{\\hbar \\pi}{4 N} n_{\\lambda}n_{\\lambda'}(n_{\\lambda''}+1)\\left|\\Phi_{\\lambda\\lambda'\\lambda''}\\right|^2 \\delta(\\omega_{\\lambda}+\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\\\ \\tilde{P}^{-}_{\\lambda\\lambda'\\lambda''}&amp;= \\frac{\\hbar \\pi}{4 N} n_{\\lambda}(n_{\\lambda'}+1)(n_{\\lambda''}+1)\\left|\\Phi_{\\lambda\\lambda'\\lambda''}\\right|^2 \\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\\\ \\tilde{P}^\\textrm{iso}_{\\lambda\\lambda'} &amp;= \\frac{\\pi}{2N} n_{\\lambda}(n_{\\lambda'}+1) \\Lambda_{\\lambda\\lambda'} \\delta(\\omega_{\\lambda}-\\omega_{\\lambda}) \\end{align} $$  What we have done here is to rearrange the transition propabilities to scattering rates. If we let  $$ \\begin{equation} \\zeta_{\\lambda}=\\frac{\\hbar}{k_B T} \\mathbf{F}_{\\lambda} \\cdot \\nabla T \\end{equation} $$  and combine everything we end up with  $$ \\begin{equation} \\begin{split} -\\frac{\\omega_{\\lambda}}{T}n_{\\lambda}(n_{\\lambda}+1)\\mathbf{v}_{\\lambda} \\cdot \\nabla T = &amp;  \\sum_{\\lambda'} \\tilde{P}^\\textrm{iso}_{\\lambda\\lambda'} \\left(\\mathbf{F}_{\\lambda}-\\mathbf{F}_{\\lambda'}\\right)\\cdot\\nabla T + \\sum_{\\lambda'\\lambda''} \\tilde{P}^{+}_{\\lambda\\lambda'\\lambda''} \\left(\\mathbf{F}_{\\lambda}+\\mathbf{F}_{\\lambda'}-\\mathbf{F}_{\\lambda''}\\right)\\cdot\\nabla T+ \\tilde{P}^{-}_{\\lambda\\lambda'\\lambda''} \\left(\\mathbf{F}_{\\lambda}-\\mathbf{F}_{\\lambda'}-\\mathbf{F}_{\\lambda''}\\right)\\cdot\\nabla T = \\\\ = &amp; \\mathbf{F}_{\\lambda}\\cdot\\nabla T \\left( \\sum_{\\lambda'} \\tilde{P}^\\textrm{iso}_{\\lambda\\lambda'} + \\sum_{\\lambda'\\lambda''} \\tilde{P}^{+}_{\\lambda\\lambda'\\lambda''}+ \\frac{1}{2}\\tilde{P}^{-}_{\\lambda\\lambda'\\lambda''} \\right)- \\\\ &amp; - \\sum_{\\lambda'} \\tilde{P}^\\textrm{iso}_{\\lambda\\lambda'}\\mathbf{F}_{\\lambda'}\\cdot\\nabla T + \\sum_{\\lambda'\\lambda''} \\tilde{P}^{+}_{\\lambda\\lambda'\\lambda''} \\left(\\mathbf{F}_{\\lambda'}-\\mathbf{F}_{\\lambda''}\\right)\\cdot\\nabla T- \\frac{1}{2}\\tilde{P}^{-}_{\\lambda\\lambda'\\lambda''} \\left(\\mathbf{F}_{\\lambda'}-\\mathbf{F}_{\\lambda''}\\right)\\cdot\\nabla T \\end{split} \\end{equation} $$  Where we can identify  $$ \\begin{equation} Q_{\\lambda}=\\sum_{\\lambda'} \\tilde{P}^\\textrm{iso}_{\\lambda\\lambda'} + \\sum_{\\lambda'\\lambda''} \\tilde{P}^{+}_{\\lambda\\lambda'\\lambda''}+ \\frac{1}{2}\\tilde{P}^{-}_{\\lambda\\lambda'\\lambda''} \\end{equation} $$  And rearrange terms  $$ \\begin{equation} \\mathbf{F}_{\\lambda}= \\frac{\\omega_{\\lambda} \\bar{n}_{\\lambda}(\\bar{n}_{\\lambda}+1)\\mathbf{v}_{\\lambda} }{T Q_{\\lambda}} + \\frac{1}{Q_{\\lambda}}\\left[ \\sum_{\\mathbf{q}'\\mathbf{q}''}\\sum_{s's''} \\tilde{P}^{+}_{\\lambda\\lambda'\\lambda''} \\left( \\mathbf{F}_{\\lambda'}-\\mathbf{F}_{\\lambda''} \\right)- \\frac{1}{2}\\tilde{P}^{-}_{\\lambda\\lambda'\\lambda''} \\left( \\mathbf{F}_{\\lambda'}-\\mathbf{F}_{\\lambda''} \\right) \\right] \\end{equation} $$  And we have a set of equations for $F$ that we can solve self-consistently. Previously, we used the imaginary part of the self-energy to get a phonon lifetime. What we got here, from Fermi golden rule, is related:  $$ \\sum_{\\lambda'} \\tilde{P}^\\textrm{iso}_{\\lambda\\lambda'} = \\frac{\\pi}{2N} n_{\\lambda}(n_{\\lambda}+1) \\sum_{\\lambda'}  \\Lambda_{\\lambda\\lambda'} \\delta(\\omega_{\\lambda}-\\omega_{\\lambda}) = 2 n_{\\lambda}(n_{\\lambda}+1) \\Gamma^{\\textrm{iso}}_{\\lambda} $$  This can also be done for the three-phonon terms:  $$ \\begin{equation} \\begin{split} \\sum_{\\lambda'\\lambda''} \\tilde{P}^{+}_{\\lambda\\lambda'\\lambda''}+ \\frac{1}{2}\\tilde{P}^{-}_{\\lambda\\lambda'\\lambda''} &amp; = \\frac{\\hbar \\pi}{8 N} \\sum_{\\lambda'\\lambda''} \\left|\\Phi_{\\lambda\\lambda'\\lambda''}\\right|^2 \\left[ n_{\\lambda}(n_{\\lambda'}+1)(n_{\\lambda''}+1) \\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}-\\omega_{\\lambda''})+ 2n_{\\lambda}n_{\\lambda'}(n_{\\lambda''}+1)\\delta(\\omega_{\\lambda}+\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\right] \\\\ &amp; = n_{\\lambda}(n_{\\lambda}+1) \\frac{\\hbar \\pi}{8 N} \\sum_{\\lambda'\\lambda''} \\left|\\Phi_{\\lambda\\lambda'\\lambda''}\\right|^2 \\left[ \\frac{n_{\\lambda}(n_{\\lambda'}+1)(n_{\\lambda''}+1)}{n_{\\lambda}(n_{\\lambda}+1)} \\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}-\\omega_{\\lambda''}) + \\frac{2n_{\\lambda}n_{\\lambda'}(n_{\\lambda''}+1)}{n_{\\lambda}(n_{\\lambda}+1)} \\delta(\\omega_{\\lambda}+\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\right] \\\\ &amp; = n_{\\lambda}(n_{\\lambda}+1) \\frac{\\hbar \\pi}{8 N} \\sum_{\\lambda'\\lambda''} \\left|\\Phi_{\\lambda\\lambda'\\lambda''}\\right|^2 \\left[ (n_{\\lambda'}+n_{\\lambda''}+1) \\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}-\\omega_{\\lambda''}) + (n_{\\lambda'}-n_{\\lambda''}) \\delta(\\omega_{\\lambda}+\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\right] \\\\ &amp; = 2 n_{\\lambda}(n_{\\lambda}+1) \\Gamma_{\\lambda} \\end{split} \\end{equation} $$  Where the second to last step seems a little impossible, but with $\\hbar\\omega/k_BT = x$, you get  $$ \\begin{equation} \\frac{  n_{\\lambda}(n_{\\lambda'}+1)(n_{\\lambda''}+1)  }{ n_{\\lambda}(n_{\\lambda}+1) } - \\left( n_{\\lambda'} + n_{\\lambda''} + 1 \\right) = \\frac{ 1-\\exp[x'+x''-x] }{ \\left( \\exp[x'] -1 \\right) \\left( \\exp[x''] -1 \\right) } \\end{equation} $$  which comes out to 0 when $x=x'+x''$, which the deltafunction ensures. In the same way  $$ \\begin{equation} \\frac{  n_{\\lambda}n_{\\lambda'}(n_{\\lambda''}+1)  }{ n_{\\lambda}(n_{\\lambda}+1) } - \\left( n_{\\lambda'} - n_{\\lambda''} \\right) = \\frac{ \\exp[-x]\\left(\\exp[x+x']-\\exp[x''] \\right) }{ \\left( \\exp[x'] -1 \\right) \\left( \\exp[x''] -1 \\right) } \\end{equation} $$  comes out to 0 when $x''=x+x'$. We can directly relate the relaxation time lifetime  $$ \\begin{equation} \\tau_{\\lambda} = \\frac{1}{2\\Gamma_{\\lambda}} = \\frac{ n_{\\lambda}(n_{\\lambda}+1) }{Q_{\\lambda}} \\end{equation} $$  to an initial guess  $$ \\mathbf{F}^0_{\\lambda} = \\frac{\\tau_{\\lambda} \\omega_{\\lambda} \\mathbf{v}_{\\lambda} }{T} $$  and iteratively solve  $$ \\begin{equation} \\mathbf{F}^{i+1}_{\\lambda}= \\mathbf{F}^0_{\\lambda} + \\frac{1}{Q_{\\lambda}}\\left[ \\sum_{\\lambda'\\lambda''} \\tilde{P}^{+}_{\\lambda\\lambda'\\lambda''} \\left( \\mathbf{F}^{i}_{\\lambda'}-\\mathbf{F}^{i}_{\\lambda''} \\right)- \\frac{1}{2}\\tilde{P}^{-}_{\\lambda\\lambda'\\lambda''} \\left( \\mathbf{F}^{i}_{\\lambda'}-\\mathbf{F}^{i}_{\\lambda''} \\right) \\right] \\end{equation} $$  to arrive at the non-equilibrium distributions. The thermal conductivity tensor is then given as  $$ \\begin{equation} \\kappa_{\\alpha\\beta} = \\frac{1}{V} \\sum_{\\lambda} \\frac{T c_{\\lambda} v_{\\lambda}^\\alpha F_{\\lambda}^\\beta}{\\omega_{\\lambda}} \\end{equation} $$      ### Cumulative kappa  @todo Check code snippets  @todo Spectral kappa, links to things.  Experimentally, the cumulative thermal conductivity with respect to phonon mean free path,  $$ l_{\\lambda} = \\left| v_{\\lambda} \\right| \\tau_{\\lambda} \\,, $$  can be measured.[^Minnich2012] The cumulative thermal conductivity can then be computed as a sum of the fraction of heat that is carried by phonons with mean free paths smaller than $l$:  $$ \\kappa_{\\alpha\\beta}^{\\textrm{acc}}(l)= \\frac{1}{V} \\sum_{\\lambda} C_{\\lambda}\u00a0v^{\\alpha}_{\\lambda} v^{\\beta}_{\\lambda} \\tau_{\\lambda} \\Theta(l- l_{\\lambda} ) \\,, $$  where $\\Theta$ is the Heaviside step function.  One can also define a spectral thermal conductivity as  $$ \\kappa_{\\alpha\\beta}(\\omega)= \\frac{1}{V} \\sum_{\\lambda} C_{\\lambda}\u00a0v^{\\alpha}_{\\lambda} v^{\\beta}_{\\lambda} \\tau_{\\lambda} \\delta(\\omega- \\omega_{\\lambda} ) $$  which is a measure which frequencies contribute most to thermal transport.  ### Thin film scattering  Constrained geometries will incur additional scattering from domain boundaries. For a thin film (thin, but thick enough that the interior of the film is accurately described by bulk phonons) one can estimate the suppression due to film thinkness.[^Minnich2015] Assyming the cross-plane direction of the film is in the $y$-direction, and the thermal gradient is applied in the $z$-direction, the in-plane thermal conductivity $\\kappa_{zz}$ is supressed as:  $$ \\kappa_{zz}(d)=A+B+C, $$  where  $$ \\begin{split} x_{\\lambda} = &amp; \\frac{\\hbar\\omega_{\\lambda}}{V} \\frac{\\partial n_{\\lambda}} {\\partial T} v_{\\lambda}^z l_{\\lambda}^z   \\\\ A = &amp; -\\frac{1}{d} \\sum_{v_y&gt;0}   x_{\\lambda} \\left(  -l^{y}_{\\lambda} \\exp\\left[\\frac{d}{l^{y}_{\\lambda}}\\right]+l^{y}_{\\lambda}-d  \\right) \\\\ B = &amp; -\\frac{1}{d} \\sum_{v_y&lt;0}   x_{\\lambda} \\left( l^{y}_{\\lambda} \\exp\\left[  -\\frac{d}{l^{y}_{\\lambda}}  \\right] -l^{y}_{\\lambda}-d \\right) \\\\ C = &amp; \\sum_{v_y=0} x_{\\lambda} \\end{split} $$  where $v_y$ and $v_z$ are the components of the phonon group velocity along the $y$ and $z$ directions, $\\tau_{\\lambda}$ is the phonon relaxation time. $l^{y}_{\\lambda}$ is the $y$ component of the MFP and $d$ is the thickness of the film in $y$-direction.  ### Input files  These files are necesarry:  * [infile.ucposcar](../page/files.html#infile.ucposcar) * [infile.forceconstant](extract_forceconstants.html#infile.forceconstant) * [infile.forceconstant_thirdorder](extract_forceconstants.html#infile.forceconstant_thirdorder)  and these are optional:  * [infile.isotopes](../page/files.html#infile.isotopes) (for non-natural isotope distribution)  ### Output files  Depending on options, the set of output files may differ. We start with the basic files that are written after running this code.  #### `outfile.thermal_conductivity`  This file contains components of the thermal conductivity tensor $\\kappa_{\\alpha \\beta}$ for each temperature.   Row Description 1      \\( T_1 \\qquad \\kappa_{xx} \\quad \\kappa_{yy} \\quad \\kappa_{zz} \\quad \\kappa_{xz} \\quad   \\kappa_{yz} \\quad   \\kappa_{xy} \\quad \\kappa_{zx} \\quad \\kappa_{zy} \\quad   \\kappa_{yx} \\)      2      \\( T_2 \\qquad \\kappa_{xx} \\quad \\kappa_{yy} \\quad \\kappa_{zz} \\quad \\kappa_{xz} \\quad   \\kappa_{yz} \\quad   \\kappa_{xy} \\quad \\kappa_{zx} \\quad \\kappa_{zy} \\quad   \\kappa_{yx} \\)      ... ...   #### `outfile.cumulative_kappa.hdf5`  This file is self-explainatory. It contains the different cumulative plots described above, at a series of temperatures. Below is a matlab snippet that plots part of the output.  <pre><code>figure(1); clf; hold on; box on;    % filename\nfn='outfile.cumulative_kappa.hdf5';\n% which temperature?\nt=1;\nsubplot(1,3,1); hold on; box on;    % read in cumulative kappa vs mean free path from file\nx=h5read(fn,['/temperature_' num2str(t) '/mean_free_path_axis']);\nxunit=h5readatt(fn,['/temperature_' num2str(t) '/mean_free_path_axis'],'unit');\ny=h5read(fn,['/temperature_' num2str(t) '/cumulative_kappa_vs_mean_free_path_total']);\n% projections to modes and/or atoms\nz=h5read(fn,['/temperature_' num2str(t) '/cumulative_kappa_vs_mean_free_path_per_atom']);\n%z=h5read(fn,['/temperature_' num2str(t) '/cumulative_kappa_vs_mean_free_path_per_mode']);\nyunit=h5readatt(fn,['/temperature_' num2str(t) '/cumulative_kappa_vs_mean_free_path_total'],'unit');\n% plot\nplot(x,y)\nplot(x,z)\n% set a legend\nlgd{1}='Total';\nfor i=1:size(z,2)\nlgd{i+1}=['Atom ' num2str(i)];\nend\nl=legend(lgd);\nset(l,'edgecolor','none','location','northwest');\n% some titles\ntitle('Cumulative kappa vs mean free path');\nylabel(['Cumulative \\kappa (' yunit ')']);\nxlabel(['Mean free path (' xunit ')']);\n% get some reasonable ranges\nminx=x(max(find(y&lt;max(y*1E-3))));\nmaxx=x(min(find(y&gt;max(y*0.9999))))*2;\nxlim([minx maxx]);\nset(gca,'xscale','log','yminortick','on');\nsubplot(1,3,2); hold on; box on;\n% read in spectral kappa vs frequency\nx=h5read(fn,['/temperature_' num2str(t) '/frequency_axis']);\ny=h5read(fn,['/temperature_' num2str(t) '/spectral_kappa_vs_frequency_total']);\nz=h5read(fn,['/temperature_' num2str(t) '/spectral_kappa_vs_frequency_per_mode']);\n%z=h5read(fn,['/temperature_' num2str(t) '/spectral_kappa_vs_frequency_per_atom']);\nplot(x,y)\nplot(x,z)\nset(gca,'xminortick','on','yminortick','on')\nxlabel('Frequency (THz)')\nylabel('Spectral \\kappa (W/m/K/THz)')\ntitle('Spectral kappa vs frequency')\nsubplot(1,3,3); hold on; box on;\n% read in cumulative kappa vs mean free path from file\nx=h5read(fn,['/temperature_' num2str(t) '/boundary_scattering_lengths']);\ny=h5read(fn,['/temperature_' num2str(t) '/boundary_scattering_kappa']);\n% grab only kxx\ny=squeeze(y(1,1,:));\nplot(x,y)\nset(gca,'xscale','log','yminortick','on')\nxlabel('Domain size (m)')\nylabel('Kappa (W/mK)')\ntitle('Kappa vs boundary scattering')\n% get a reasonable range in x\nminx=max(x(find(y&lt;max(y*1E-2))))\nmaxx=x(min(find(y&gt;max(y*0.9999))))*2\nxlim([minx maxx])\n</code></pre>  #### `outfile.grid_thermal_conductivity.hdf5`  Option `--dumpgrid` produces this self-explainatory file. It will not get written if you use more than one temperature, the reason is that this file can get uncomfortably large, nearly all quantities on the full q-grid are written. Below is a matlab snippet that plots a subset:  <pre><code>% file to read from\nfn='outfile.grid_thermal_conductivity.hdf5';\n% convert units to THz from Hz?\ntoTHz=1/1E12/2/pi;\nfigure(1); clf; hold on;\nsubplot(1,3,1); hold on; box on;\nx=h5read(fn,'/frequencies');\ny=h5read(fn,'/linewidths');\nfor i=1:size(x,1)\nplot(x(i,:)*toTHz,y(i,:)*toTHz,'marker','.','linestyle','none','markersize',8)\nend\nset(gca,'xminortick','on','yminortick','on')\nxlabel('Frequency (THz)')\nylabel('Linewidth (THz)')\nsubplot(1,3,2); hold on; box on;\nx=h5read(fn,'/frequencies');\ny=h5read(fn,'/lifetimes');\nfor i=1:size(x,1)\nplot(x(i,:)*toTHz,y(i,:),'marker','.','linestyle','none','markersize',8)\nend\nset(gca,'yscale','log','xminortick','on')\nxlabel('Frequency (THz)')\nylabel('Lifetime (s)')\nsubplot(1,3,3); hold on; box on;\nx=h5read(fn,'/frequencies');\ny=h5read(fn,'/mean_free_paths');\nfor i=1:size(x,1)\nplot(x(i,:)*toTHz,y(i,:),'marker','.','linestyle','none','markersize',8)\nend\nset(gca,'yscale','log','xminortick','on')\nxlabel('Frequency (THz)')\nylabel('Mean free paths (m)')\n</code></pre>  [^peierls1929]: Peierls, R. E. (1929). Annalen der Physik, 3, 1055  [^peierls1955quantum]: [Peierls, R. E. (1955). Quantum Theory of Solids. Clarendon Press.](https://books.google.com/books?id=WvPcBUsSJBAC)  [^Minnich2012]: [Minnich, A. J. (2012). Determining phonon mean free paths from observations of quasiballistic thermal transport. Physical Review Letters, 109(20), 1\u20135.](http://doi.org/10.1103/PhysRevLett.109.205901)  [^Minnich2015]: [Minnich, A. J. (2015). Thermal phonon boundary scattering in anisotropic thin films. Applied Physics Letters, 107(18), 8\u201311.](http://doi.org/10.1063/1.4935160)  [^Tamura1983]: [Tamura, S. (1983). Isotope scattering of dispersive phonons in Ge. Physical Review B, 27(2), 858\u2013866.](http://doi.org/10.1103/PhysRevB.27.858)  [^Omini1996]: [Omini, M., &amp; Sparavigna, A. (1996). Beyond the isotropic-model approximation in the theory of thermal conductivity. Physical Review B, 53(14), 9064\u20139073.](http://doi.org/10.1103/PhysRevB.53.9064)  [^Omini]: [Omini, M., &amp; Sparavigna, A. (1997). Heat transport in dielectric solids with diamond structure. Nuovo Cimento Della Societa Italiana Di Fisica D, 19D, 1537\u201363.](http://www.sif.it/riviste/ncd/econtents/1997/019/10/article/5)  [^Broido2007]: [Broido, D. A., Malorny, M., Birner, G., Mingo, N., &amp; Stewart, D. A. (2007). Intrinsic lattice thermal conductivity of semiconductors from first principles. Applied Physics Letters, 91(23), 231922.](http://doi.org/10.1063/1.2822891)  [^Broido2005]: [Broido, D. A., Ward, A., &amp; Mingo, N. (2005). Lattice thermal conductivity of silicon from empirical interatomic potentials. Physical Review B, 72(1), 1\u20138.](http://doi.org/10.1103/PhysRevB.72.014308)"}]}